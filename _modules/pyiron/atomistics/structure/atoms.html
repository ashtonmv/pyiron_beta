

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pyiron.atomistics.structure.atoms &mdash; pyiron 0.2.17.post.dev166 documentation</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../../_static/pyiron_logo.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home" alt="Documentation Home"> pyiron
          

          
            
            <img src="../../../../_static/pyiron-logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/examples.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/team.html">Team</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/software.html">Collaborators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/commandline.html">Command Line Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/citation.html">Citing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/developers.html">Contributing to pyiron</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/pyiron/pyiron/blob/master/LICENSE">License (BSD)</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pyiron.readthedocs.io/en/latest/py-modindex.html">Module index</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.mpie.de/impressum">Imprint</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.mpie.de/3392182/data-protection">Data protection</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">pyiron</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../../pyiron.html">pyiron</a> &raquo;</li>
        
      <li>pyiron.atomistics.structure.atoms</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pyiron.atomistics.structure.atoms</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding: utf-8</span>
<span class="c1"># Copyright (c) Max-Planck-Institut für Eisenforschung GmbH - Computational Materials Design (CM) Department</span>
<span class="c1"># Distributed under the terms of &quot;New BSD License&quot;, see the LICENSE file.</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">ast</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="kn">import</span> <span class="n">string_types</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">ase.geometry</span> <span class="kn">import</span> <span class="n">cellpar_to_cell</span><span class="p">,</span> <span class="n">complete_cell</span><span class="p">,</span> <span class="n">get_distances</span>
<span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="n">rgb2hex</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">import</span> <span class="nn">seekpath</span>
<span class="kn">from</span> <span class="nn">pyiron.atomistics.structure.atom</span> <span class="kn">import</span> <span class="n">Atom</span>
<span class="kn">from</span> <span class="nn">pyiron.atomistics.structure.sparse_list</span> <span class="kn">import</span> <span class="n">SparseArray</span><span class="p">,</span> <span class="n">SparseList</span>
<span class="kn">from</span> <span class="nn">pyiron.atomistics.structure.periodic_table</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">PeriodicTable</span><span class="p">,</span>
    <span class="n">ChemicalElement</span><span class="p">,</span>
    <span class="n">ElementColorDictionary</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyiron.base.settings.generic</span> <span class="kn">import</span> <span class="n">Settings</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">cKDTree</span><span class="p">,</span> <span class="n">Voronoi</span>
<span class="kn">import</span> <span class="nn">spglib</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Joerg Neugebauer, Sudarsan Surendralal&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;Copyright 2020, Max-Planck-Institut für Eisenforschung GmbH - &quot;</span>
    <span class="s2">&quot;Computational Materials Design (CM) Department&quot;</span>
<span class="p">)</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;1.0&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s2">&quot;Sudarsan Surendralal&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s2">&quot;surendralal@mpie.de&quot;</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s2">&quot;production&quot;</span>
<span class="n">__date__</span> <span class="o">=</span> <span class="s2">&quot;Sep 1, 2017&quot;</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Settings</span><span class="p">()</span>


<div class="viewcode-block" id="Atoms"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms">[docs]</a><span class="k">class</span> <span class="nc">Atoms</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The Atoms class represents all the information required to describe a structure at the atomic scale. This class is</span>
<span class="sd">    written in such a way that is compatible with the `ASE atoms class`_. Some of the functions in this module is based</span>
<span class="sd">    on the corresponding implementation in the ASE package</span>

<span class="sd">    Args:</span>
<span class="sd">        elements (list/numpy.ndarray): List of strings containing the elements or a list of</span>
<span class="sd">                            atomistics.structure.periodic_table.ChemicalElement instances</span>
<span class="sd">        numbers (list/numpy.ndarray): List of atomic numbers of elements</span>
<span class="sd">        symbols (list/numpy.ndarray): List of chemical symbols</span>
<span class="sd">        positions (list/numpy.ndarray): List of positions</span>
<span class="sd">        scaled_positions (list/numpy.ndarray): List of scaled positions (relative coordinates)</span>
<span class="sd">        pbc (list/numpy.ndarray/boolean): Tells if periodic boundary conditions should be applied on the three axes</span>
<span class="sd">        cell (list/numpy.ndarray instance): A 3x3 array representing the lattice vectors of the structure</span>

<span class="sd">    Note: Only one of elements/symbols or numbers should be assigned during initialization</span>

<span class="sd">    Attributes:</span>

<span class="sd">        indices (numpy.ndarray): A list of size N which gives the species index of the structure which has N atoms</span>

<span class="sd">    .. _ASE atoms class: https://wiki.fysik.dtu.dk/ase/ase/atoms.html</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">symbols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">numbers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">momenta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">masses</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">magmoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">charges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">scaled_positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cell</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pbc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">celldisp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">constraint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">calculator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">elements</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">species</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">qwargs</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">symbols</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">elements</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">elements</span> <span class="o">=</span> <span class="n">symbols</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only elements OR symbols should be given.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">tags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="n">momenta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="n">masses</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="n">charges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="n">celldisp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="n">constraint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="n">calculator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="n">info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="n">s</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Not supported parameter used!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_store_elements</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_species_to_index_dict</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colorLut</span> <span class="o">=</span> <span class="n">ElementColorDictionary</span><span class="p">()</span><span class="o">.</span><span class="n">to_lut</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_scaled</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">cell</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># make it ASE compatible</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="p">))</span> <span class="o">*</span> <span class="n">cell</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cell</span> <span class="o">=</span> <span class="n">cell</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_species</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pse</span> <span class="o">=</span> <span class="n">PeriodicTable</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span> <span class="o">=</span> <span class="n">SparseArray</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adsorbate_info</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pbc</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># Default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;length&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;mass&quot;</span><span class="p">:</span> <span class="s2">&quot;u&quot;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_symmetry_dataset</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">el_index_lst</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">element_list</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">elements</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">numbers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">numbers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># for ASE compatibility</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">elements</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">()</span>
            <span class="n">elements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numbers_to_elements</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">elements</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">el_object_list</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">element_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_formula</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">elements</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">]):</span>
                    <span class="n">object_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">)):</span>
                            <span class="n">object_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_element</span><span class="p">(</span><span class="n">el</span><span class="p">))</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">ChemicalElement</span><span class="p">):</span>
                            <span class="n">object_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">Atom</span><span class="p">):</span>
                            <span class="n">object_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">element</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
                            <span class="c1"># pse = PeriodicTable()</span>
                            <span class="n">object_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pse</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">el</span><span class="p">))</span>
                        <span class="n">el_object_list</span> <span class="o">=</span> <span class="n">object_list</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">element_list</span> <span class="o">=</span> <span class="n">elements</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                        <span class="n">elements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">string_types</span><span class="p">):</span>
                        <span class="n">element_list</span> <span class="o">=</span> <span class="n">elements</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ChemicalElement</span><span class="p">):</span>
                        <span class="n">el_object_list</span> <span class="o">=</span> <span class="n">elements</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Atom</span><span class="p">):</span>
                        <span class="n">el_object_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">element</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">]</span>
                        <span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">position</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">elements</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">]:</span>
                        <span class="n">el_object_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numbers_to_elements</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Unknown static type for element in list: &quot;</span>
                            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                        <span class="p">)</span>

            <span class="k">if</span> <span class="n">el_object_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">el_object_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_element</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">element_list</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">set_species</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">el_object_list</span><span class="p">)))</span>
            <span class="c1"># species_to_index_dict = {el: i for i, el in enumerate(self.species)}</span>
            <span class="n">el_index_lst</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_species_to_index_dict</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">el_object_list</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">el_index_lst</span> <span class="o">=</span> <span class="n">indices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_species</span><span class="p">(</span><span class="n">species</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scaled_positions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">positions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;either position or scaled_positions can be given&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cell</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;scaled_positions can only be used with a given cell&quot;</span><span class="p">)</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scaled_positions</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="n">positions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="k">if</span> <span class="n">cell</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">el_index_lst</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">el_index_lst</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="o">.</span><span class="n">_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">qwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;set qwargs (ASE): &quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">dimension</span>
        <span class="k">if</span> <span class="n">cell</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pbc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># default setting</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="n">pbc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_initial_magnetic_moments</span><span class="p">(</span><span class="n">magmoms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_high_symmetry_points</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_high_symmetry_path</span> <span class="o">=</span> <span class="kc">None</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        numpy.ndarray: A size 3x3 array which gives the lattice vectors of the cell as [a1, a2, a3]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cell</span>

    <span class="nd">@cell</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cell</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_scaled</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_cell</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">scale_atoms</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_cell</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">species</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        list: A list of atomistics.structure.periodic_table.ChemicalElement instances</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_species</span>

    <span class="c1"># @species.setter</span>
<div class="viewcode-block" id="Atoms.set_species"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.set_species">[docs]</a>    <span class="k">def</span> <span class="nf">set_species</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setting the species list</span>

<span class="sd">        Args:</span>
<span class="sd">            value (list): A list atomistics.structure.periodic_table.ChemicalElement instances</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_species_to_index_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">el</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_species</span> <span class="o">=</span> <span class="n">value</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_store_elements</span> <span class="o">=</span> <span class="p">{</span><span class="n">el</span><span class="o">.</span><span class="n">Abbreviation</span><span class="p">:</span> <span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">value</span><span class="p">}</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        dict: This dictionary is merely used to be compatible with the ASE Atoms class.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info</span>

    <span class="nd">@info</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_info</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pbc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        list: A list of boolean values which gives the periodic boundary consitions along the three axes.</span>
<span class="sd">              The default value is [True, True, True]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pbc</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_pbc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pbc</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pbc</span>

    <span class="nd">@pbc</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">pbc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pbc</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">elements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        numpy.ndarray: A size N list of atomistics.structure.periodic_table.ChemicalElement instances according</span>
<span class="sd">                       to the ordering of the atoms in the instance</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">])</span>

<div class="viewcode-block" id="Atoms.get_high_symmetry_points"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_high_symmetry_points">[docs]</a>    <span class="k">def</span> <span class="nf">get_high_symmetry_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        dictionary of high-symmetry points defined for this specific structure.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: high_symmetry_points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_high_symmetry_points</span></div>

    <span class="k">def</span> <span class="nf">_set_high_symmetry_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_high_symmetry_points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets new high symmetry points dictionary.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_high_symmetry_points (dict): new high symmetry points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_high_symmetry_points</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;has to be dict!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_high_symmetry_points</span> <span class="o">=</span> <span class="n">new_high_symmetry_points</span>

<div class="viewcode-block" id="Atoms.add_high_symmetry_points"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.add_high_symmetry_points">[docs]</a>    <span class="k">def</span> <span class="nf">add_high_symmetry_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds new points to the dict of existing high symmetry points.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_points (dict): Points to add</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_high_symmetry_points</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Construct high symmetry points first. Use self.create_line_mode_structure().&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_high_symmetry_points</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_points</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.get_high_symmetry_path"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_high_symmetry_path">[docs]</a>    <span class="k">def</span> <span class="nf">get_high_symmetry_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Path used for band structure calculations</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: dict of pathes with start and end points.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_high_symmetry_path</span></div>

    <span class="k">def</span> <span class="nf">_set_high_symmetry_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets new list for the high symmetry path used for band structure calculations.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_path (dict): dictionary of lists of tuples with start and end point.</span>
<span class="sd">                E.G. {&quot;my_path&quot;: [(&#39;Gamma&#39;, &#39;X&#39;), (&#39;X&#39;, &#39;Y&#39;)]}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_high_symmetry_path</span> <span class="o">=</span> <span class="n">new_path</span>

<div class="viewcode-block" id="Atoms.add_high_symmetry_path"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.add_high_symmetry_path">[docs]</a>    <span class="k">def</span> <span class="nf">add_high_symmetry_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a new path to the dictionary of pathes for band structure calculations.</span>

<span class="sd">        Args:</span>
<span class="sd">            path (dict): dictionary of lists of tuples with start and end point.</span>
<span class="sd">                E.G. {&quot;my_path&quot;: [(&#39;Gamma&#39;, &#39;X&#39;), (&#39;X&#39;, &#39;Y&#39;)]}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_high_symmetry_path</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Construct high symmetry path first. Use self.create_line_mode_structure().&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">values_all</span> <span class="ow">in</span> <span class="n">path</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">values_all</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39; is not a propper trace! It has to contain exactly 2 values! (start and end point)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">values</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_high_symmetry_points</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39; is not a valid high symmetry point&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_high_symmetry_path</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.new_array"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.new_array">[docs]</a>    <span class="k">def</span> <span class="nf">new_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adding a new array to the instance. This function is for the purpose of compatibility with the ASE package</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str): Name of the array</span>
<span class="sd">            a (list/numpy.ndarray): The array to be added</span>
<span class="sd">            dtype (type): Data type of the array</span>
<span class="sd">            shape (list/turple): Shape of the array</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;C_CONTIGUOUS&quot;</span><span class="p">]:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Array has wrong length: </span><span class="si">%d</span><span class="s2"> != </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>
            <span class="k">break</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Array has wrong shape </span><span class="si">%s</span><span class="s2"> != </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">shape</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span></div>

<div class="viewcode-block" id="Atoms.get_array"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_array">[docs]</a>    <span class="k">def</span> <span class="nf">get_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an array. This function is for the purpose of compatibility with the ASE package</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str): Name of the required array</span>
<span class="sd">            copy (bool): True if a copy of the array is to be returned</span>

<span class="sd">        Returns:</span>
<span class="sd">             An array of a copy of the array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">[</span><span class="n">name</span><span class="p">]</span></div>

<div class="viewcode-block" id="Atoms.set_array"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.set_array">[docs]</a>    <span class="k">def</span> <span class="nf">set_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update array. This function is for the purpose of compatibility with the ASE package</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str): Name of the array</span>
<span class="sd">            a (list/numpy.ndarray): The array to be added</span>
<span class="sd">            dtype (type): Data type of the array</span>
<span class="sd">            shape (list/turple): Shape of the array</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">new_array</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Array has wrong shape </span><span class="si">%s</span><span class="s2"> != </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">b</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">a</span></div>

<div class="viewcode-block" id="Atoms.add_tag"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.add_tag">[docs]</a>    <span class="k">def</span> <span class="nf">add_tag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">qwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add tags to the atoms object.</span>

<span class="sd">        Examples:</span>

<span class="sd">            For selective dynamics::</span>

<span class="sd">            &gt;&gt;&gt; self.add_tag(selective_dynamics=[False, False, False])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="o">.</span><span class="n">add_tag</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">qwargs</span><span class="p">)</span></div>

    <span class="c1"># @staticmethod</span>
<div class="viewcode-block" id="Atoms.numbers_to_elements"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.numbers_to_elements">[docs]</a>    <span class="k">def</span> <span class="nf">numbers_to_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numbers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert atomic numbers in element objects (needed for compatibility with ASE)</span>

<span class="sd">        Args:</span>
<span class="sd">            numbers (list): List of Element Numbers (as Integers; default in ASE)</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: A list of elements as needed for pyiron</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pse = PeriodicTable()  # TODO; extend to internal PSE which can contain additional elements and tags</span>
        <span class="n">atom_number_to_element</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i_el</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">numbers</span><span class="p">):</span>
            <span class="n">i_el</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i_el</span><span class="p">)</span>
            <span class="n">atom_number_to_element</span><span class="p">[</span><span class="n">i_el</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pse</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">i_el</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">atom_number_to_element</span><span class="p">[</span><span class="n">i_el</span><span class="p">]</span> <span class="k">for</span> <span class="n">i_el</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">]</span></div>

<div class="viewcode-block" id="Atoms.copy"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of the instance</span>

<span class="sd">        Returns:</span>
<span class="sd">            pyiron.atomistics.structure.atoms.Atoms: A copy of the instance</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__copy__</span><span class="p">()</span></div>

<div class="viewcode-block" id="Atoms.to_hdf"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.to_hdf">[docs]</a>    <span class="k">def</span> <span class="nf">to_hdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdf</span><span class="p">,</span> <span class="n">group_name</span><span class="o">=</span><span class="s2">&quot;structure&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the object in a HDF5 file</span>

<span class="sd">        Args:</span>
<span class="sd">            hdf (pyiron.base.generic.hdfio.FileHDFio): HDF path to which the object is to be saved</span>
<span class="sd">            group_name (str):</span>
<span class="sd">                Group name with which the object should be stored. This same name should be used to retrieve the object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># import time</span>
        <span class="k">with</span> <span class="n">hdf</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">group_name</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdf_structure</span><span class="p">:</span>
            <span class="c1"># time_start = time.time()</span>
            <span class="n">hdf_structure</span><span class="p">[</span><span class="s2">&quot;TYPE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">tags</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="k">with</span> <span class="n">hdf_structure</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;new_species&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdf_species</span><span class="p">:</span>
                        <span class="n">el</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="n">hdf_species</span><span class="p">)</span>
            <span class="n">hdf_structure</span><span class="p">[</span><span class="s2">&quot;species&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">Abbreviation</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">]</span>
            <span class="n">hdf_structure</span><span class="p">[</span><span class="s2">&quot;indices&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span>

            <span class="k">with</span> <span class="n">hdf_structure</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;tags&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdf_tags</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">tag_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tag_value</span><span class="p">,</span> <span class="n">SparseList</span><span class="p">):</span>
                        <span class="n">tag_value</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="n">hdf_tags</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
            <span class="n">hdf_structure</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span>
            <span class="n">hdf_structure</span><span class="p">[</span><span class="s2">&quot;dimension&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">hdf_structure</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;cell&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdf_cell</span><span class="p">:</span>
                    <span class="n">hdf_cell</span><span class="p">[</span><span class="s2">&quot;cell&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span>
                    <span class="n">hdf_cell</span><span class="p">[</span><span class="s2">&quot;pbc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span>

            <span class="c1"># hdf_structure[&quot;coordinates&quot;] = self.positions  # &quot;Atomic coordinates&quot;</span>
            <span class="n">hdf_structure</span><span class="p">[</span><span class="s2">&quot;positions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span>  <span class="c1"># &quot;Atomic coordinates&quot;</span>

            <span class="c1"># potentials with explicit bonds (TIP3P, harmonic, etc.)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">hdf_structure</span><span class="p">[</span><span class="s2">&quot;explicit_bonds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span>

            <span class="c1"># print (&#39;time in atoms.to_hdf: &#39;, time.time() - time_start)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_high_symmetry_points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">hdf_structure</span><span class="p">[</span><span class="s2">&quot;high_symmetry_points&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_high_symmetry_points</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_high_symmetry_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">hdf_structure</span><span class="p">[</span><span class="s2">&quot;high_symmetry_path&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_high_symmetry_path</span></div>

<div class="viewcode-block" id="Atoms.from_hdf"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.from_hdf">[docs]</a>    <span class="k">def</span> <span class="nf">from_hdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdf</span><span class="p">,</span> <span class="n">group_name</span><span class="o">=</span><span class="s2">&quot;structure&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the object from a HDF5 file</span>

<span class="sd">        Args:</span>
<span class="sd">            hdf (pyiron.base.generic.hdfio.FileHDFio): HDF path to which the object is to be saved</span>
<span class="sd">            group_name (str): Group name from which the Atoms object is retreived.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pyiron_atomistic.structure.atoms.Atoms: The retrieved atoms class</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;indices&quot;</span> <span class="ow">in</span> <span class="n">hdf</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span><span class="o">.</span><span class="n">list_nodes</span><span class="p">():</span>
            <span class="k">with</span> <span class="n">hdf</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">group_name</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdf_atoms</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;new_species&quot;</span> <span class="ow">in</span> <span class="n">hdf_atoms</span><span class="o">.</span><span class="n">list_groups</span><span class="p">():</span>
                    <span class="k">with</span> <span class="n">hdf_atoms</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;new_species&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdf_species</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_pse</span><span class="o">.</span><span class="n">from_hdf</span><span class="p">(</span><span class="n">hdf_species</span><span class="p">)</span>

                <span class="n">el_object_list</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">convert_element</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pse</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">hdf_atoms</span><span class="p">[</span><span class="s2">&quot;species&quot;</span><span class="p">]</span>
                <span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">hdf_atoms</span><span class="p">[</span><span class="s2">&quot;indices&quot;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="o">.</span><span class="n">_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">set_species</span><span class="p">(</span><span class="n">el_object_list</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="s2">&quot;explicit_bonds&quot;</span> <span class="ow">in</span> <span class="n">hdf_atoms</span><span class="o">.</span><span class="n">list_nodes</span><span class="p">():</span>
                    <span class="c1"># print &quot;bonds: &quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span> <span class="o">=</span> <span class="n">hdf_atoms</span><span class="p">[</span><span class="s2">&quot;explicit_bonds&quot;</span><span class="p">]</span>

                <span class="k">if</span> <span class="s2">&quot;tags&quot;</span> <span class="ow">in</span> <span class="n">hdf_atoms</span><span class="o">.</span><span class="n">list_groups</span><span class="p">():</span>
                    <span class="k">with</span> <span class="n">hdf_atoms</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;tags&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdf_tags</span><span class="p">:</span>
                        <span class="n">tags</span> <span class="o">=</span> <span class="n">hdf_tags</span><span class="o">.</span><span class="n">list_nodes</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">tags</span><span class="p">:</span>
                            <span class="c1"># tr_dict = {&#39;0&#39;: False, &#39;1&#39;: True}</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hdf_tags</span><span class="p">[</span><span class="n">tag</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                                <span class="n">my_list</span> <span class="o">=</span> <span class="n">hdf_tags</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">SparseList</span><span class="p">(</span>
                                    <span class="n">my_list</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                                <span class="p">)</span>

                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">my_dict</span> <span class="o">=</span> <span class="n">hdf_tags</span><span class="o">.</span><span class="n">get_pandas</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
                                <span class="n">my_dict</span> <span class="o">=</span> <span class="p">{</span>
                                    <span class="n">i</span><span class="p">:</span> <span class="n">val</span>
                                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                                        <span class="n">my_dict</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">],</span> <span class="n">my_dict</span><span class="p">[</span><span class="s2">&quot;values&quot;</span><span class="p">]</span>
                                    <span class="p">)</span>
                                <span class="p">}</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">SparseList</span><span class="p">(</span>
                                    <span class="n">my_dict</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                                <span class="p">)</span>

                <span class="n">tr_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">hdf_atoms</span><span class="p">[</span><span class="s2">&quot;dimension&quot;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">hdf_atoms</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="s2">&quot;cell&quot;</span> <span class="ow">in</span> <span class="n">hdf_atoms</span><span class="o">.</span><span class="n">list_groups</span><span class="p">():</span>
                    <span class="k">with</span> <span class="n">hdf_atoms</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;cell&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdf_cell</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">=</span> <span class="n">hdf_cell</span><span class="p">[</span><span class="s2">&quot;cell&quot;</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="n">hdf_cell</span><span class="p">[</span><span class="s2">&quot;pbc&quot;</span><span class="p">]</span>

                <span class="c1"># Backward compatibility</span>
                <span class="n">position_tag</span> <span class="o">=</span> <span class="s2">&quot;positions&quot;</span>
                <span class="k">if</span> <span class="n">position_tag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hdf_atoms</span><span class="o">.</span><span class="n">list_nodes</span><span class="p">():</span>
                    <span class="n">position_tag</span> <span class="o">=</span> <span class="s2">&quot;coordinates&quot;</span>
                <span class="k">if</span> <span class="s2">&quot;is_absolute&quot;</span> <span class="ow">in</span> <span class="n">hdf_atoms</span><span class="o">.</span><span class="n">list_nodes</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">tr_dict</span><span class="p">[</span><span class="n">hdf_atoms</span><span class="p">[</span><span class="s2">&quot;is_absolute&quot;</span><span class="p">]]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_scaled_positions</span><span class="p">(</span><span class="n">hdf_atoms</span><span class="p">[</span><span class="n">position_tag</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">hdf_atoms</span><span class="p">[</span><span class="n">position_tag</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">hdf_atoms</span><span class="p">[</span><span class="n">position_tag</span><span class="p">]</span>

                <span class="k">if</span> <span class="s2">&quot;bonds&quot;</span> <span class="ow">in</span> <span class="n">hdf_atoms</span><span class="o">.</span><span class="n">list_nodes</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span> <span class="o">=</span> <span class="n">hdf_atoms</span><span class="p">[</span><span class="s2">&quot;explicit_bonds&quot;</span><span class="p">]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_high_symmetry_points</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="s2">&quot;high_symmetry_points&quot;</span> <span class="ow">in</span> <span class="n">hdf_atoms</span><span class="o">.</span><span class="n">list_nodes</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_high_symmetry_points</span> <span class="o">=</span> <span class="n">hdf_atoms</span><span class="p">[</span><span class="s2">&quot;high_symmetry_points&quot;</span><span class="p">]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_high_symmetry_path</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="s2">&quot;high_symmetry_path&quot;</span> <span class="ow">in</span> <span class="n">hdf_atoms</span><span class="o">.</span><span class="n">list_nodes</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_high_symmetry_path</span> <span class="o">=</span> <span class="n">hdf_atoms</span><span class="p">[</span><span class="s2">&quot;high_symmetry_path&quot;</span><span class="p">]</span>
                <span class="k">return</span> <span class="bp">self</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_hdf_old</span><span class="p">(</span><span class="n">hdf</span><span class="p">,</span> <span class="n">group_name</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_from_hdf_old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdf</span><span class="p">,</span> <span class="n">group_name</span><span class="o">=</span><span class="s2">&quot;structure&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function exits merely for the purpose of backward compatibility</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">hdf</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">group_name</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdf_atoms</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pse</span> <span class="o">=</span> <span class="n">PeriodicTable</span><span class="p">()</span>
            <span class="k">if</span> <span class="s2">&quot;species&quot;</span> <span class="ow">in</span> <span class="n">hdf_atoms</span><span class="o">.</span><span class="n">list_groups</span><span class="p">():</span>
                <span class="k">with</span> <span class="n">hdf_atoms</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;species&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdf_species</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_pse</span><span class="o">.</span><span class="n">from_hdf</span><span class="p">(</span><span class="n">hdf_species</span><span class="p">)</span>
            <span class="n">chemical_symbols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hdf_atoms</span><span class="p">[</span><span class="s2">&quot;elements&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
            <span class="n">el_object_list</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">convert_element</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pse</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">chemical_symbols</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_species</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">el_object_list</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_species_to_index_dict</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">el_object_list</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="o">.</span><span class="n">_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="s2">&quot;explicit_bonds&quot;</span> <span class="ow">in</span> <span class="n">hdf_atoms</span><span class="o">.</span><span class="n">list_nodes</span><span class="p">():</span>
                <span class="c1"># print &quot;bonds: &quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span> <span class="o">=</span> <span class="n">hdf_atoms</span><span class="p">[</span><span class="s2">&quot;explicit_bonds&quot;</span><span class="p">]</span>

            <span class="k">if</span> <span class="s2">&quot;tags&quot;</span> <span class="ow">in</span> <span class="n">hdf_atoms</span><span class="o">.</span><span class="n">list_groups</span><span class="p">():</span>
                <span class="k">with</span> <span class="n">hdf_atoms</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;tags&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdf_tags</span><span class="p">:</span>
                    <span class="n">tags</span> <span class="o">=</span> <span class="n">hdf_tags</span><span class="o">.</span><span class="n">list_nodes</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">tags</span><span class="p">:</span>
                        <span class="c1"># tr_dict = {&#39;0&#39;: False, &#39;1&#39;: True}</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hdf_tags</span><span class="p">[</span><span class="n">tag</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                            <span class="n">my_list</span> <span class="o">=</span> <span class="n">hdf_tags</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">SparseList</span><span class="p">(</span><span class="n">my_list</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">my_dict</span> <span class="o">=</span> <span class="n">hdf_tags</span><span class="o">.</span><span class="n">get_pandas</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
                            <span class="n">my_dict</span> <span class="o">=</span> <span class="p">{</span>
                                <span class="n">i</span><span class="p">:</span> <span class="n">val</span>
                                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">my_dict</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">],</span> <span class="n">my_dict</span><span class="p">[</span><span class="s2">&quot;values&quot;</span><span class="p">])</span>
                            <span class="p">}</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">SparseList</span><span class="p">(</span><span class="n">my_dict</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="s2">&quot;cell&quot;</span> <span class="ow">in</span> <span class="n">hdf_atoms</span><span class="o">.</span><span class="n">list_groups</span><span class="p">():</span>
                <span class="k">with</span> <span class="n">hdf_atoms</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;cell&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdf_cell</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">=</span> <span class="n">hdf_cell</span><span class="p">[</span><span class="s2">&quot;cell&quot;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="n">hdf_cell</span><span class="p">[</span><span class="s2">&quot;pbc&quot;</span><span class="p">]</span>

            <span class="n">tr_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">hdf_atoms</span><span class="p">[</span><span class="s2">&quot;dimension&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;is_absolute&quot;</span> <span class="ow">in</span> <span class="n">hdf_atoms</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tr_dict</span><span class="p">[</span><span class="n">hdf_atoms</span><span class="p">[</span><span class="s2">&quot;is_absolute&quot;</span><span class="p">]]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">hdf_atoms</span><span class="p">[</span><span class="s2">&quot;coordinates&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_scaled_positions</span><span class="p">(</span><span class="n">hdf_atoms</span><span class="p">[</span><span class="s2">&quot;coordinates&quot;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">hdf_atoms</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span>

            <span class="k">if</span> <span class="s2">&quot;bonds&quot;</span> <span class="ow">in</span> <span class="n">hdf_atoms</span><span class="o">.</span><span class="n">list_nodes</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span> <span class="o">=</span> <span class="n">hdf_atoms</span><span class="p">[</span><span class="s2">&quot;explicit_bonds&quot;</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_high_symmetry_points</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="s2">&quot;high_symmetry_points&quot;</span> <span class="ow">in</span> <span class="n">hdf_atoms</span><span class="o">.</span><span class="n">list_nodes</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_high_symmetry_points</span> <span class="o">=</span> <span class="n">hdf_atoms</span><span class="p">[</span><span class="s2">&quot;high_symmetry_points&quot;</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="Atoms.center"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.center">[docs]</a>    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vacuum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Center atoms in unit cell.</span>

<span class="sd">        Adopted from ASE code (https://wiki.fysik.dtu.dk/ase/_modules/ase/atoms.html#Atoms.center)</span>

<span class="sd">        Args:</span>
<span class="sd">            vacuum (float): If specified adjust the amount of vacuum when centering. If vacuum=10.0 there will thus be</span>
<span class="sd">                            10 Angstrom of vacuum on each side.</span>
<span class="sd">            axis (tuple/list): List or turple of integers specifying the axis along which the atoms should be centered</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Find the orientations of the faces of the unit cell</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_cell</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

        <span class="n">dirs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">dirs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">dirs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dirs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="c1"># normalize</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dirs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">dirs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># Now, decide how much each basis vector should be made longer</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span>
        <span class="n">longer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dirs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dirs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">height</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dirs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">vacuum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lng</span> <span class="o">=</span> <span class="p">(</span><span class="n">p1</span> <span class="o">-</span> <span class="n">p0</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">vacuum</span><span class="p">)</span> <span class="o">-</span> <span class="n">height</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lng</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Do not change unit cell size!</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">lng</span> <span class="o">+</span> <span class="n">height</span> <span class="o">-</span> <span class="n">p1</span>
            <span class="n">shf</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">top</span> <span class="o">-</span> <span class="n">p0</span><span class="p">)</span>
            <span class="n">cosphi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dirs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">longer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lng</span> <span class="o">/</span> <span class="n">cosphi</span>
            <span class="n">shift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">shf</span> <span class="o">/</span> <span class="n">cosphi</span>

        <span class="c1"># Now, do it!</span>
        <span class="n">translation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">nowlen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">cell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">longer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">nowlen</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_cell</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
            <span class="n">translation</span> <span class="o">+=</span> <span class="n">shift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">nowlen</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">+=</span> <span class="n">translation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">*</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span></div>

<div class="viewcode-block" id="Atoms.set_positions"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.set_positions">[docs]</a>    <span class="k">def</span> <span class="nf">set_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">positions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set positions. This function is for compatability with ASE</span>

<span class="sd">        Args:</span>
<span class="sd">            positions (numpy.ndarray/list): Positions in absolute coordinates</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="o">.</span><span class="n">_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.get_positions"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_positions">[docs]</a>    <span class="k">def</span> <span class="nf">get_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get positions. This function is for compatability with ASE</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Positions in absolute coordinates</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span></div>

<div class="viewcode-block" id="Atoms.select_index"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.select_index">[docs]</a>    <span class="k">def</span> <span class="nf">select_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">el</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the indices of a given element in the structure</span>

<span class="sd">        Args:</span>
<span class="sd">            el (str/atomistics.structures.periodic_table.ChemicalElement/list): Element for which the indices should</span>
<span class="sd">                                                                                  be returned</span>
<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: An array of indices of the atoms of the given element</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()</span> <span class="o">==</span> <span class="n">el</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">ChemicalElement</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">([</span><span class="n">e</span> <span class="o">==</span> <span class="n">el</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_chemical_elements</span><span class="p">()])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">(),</span> <span class="n">el</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ChemicalElement</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">([</span><span class="n">e</span> <span class="ow">in</span> <span class="n">el</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_chemical_elements</span><span class="p">()])[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Atoms.select_parent_index"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.select_parent_index">[docs]</a>    <span class="k">def</span> <span class="nf">select_parent_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">el</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the indices of a given element in the structure ignoring user defined elements</span>

<span class="sd">        Args:</span>
<span class="sd">            el (str/atomistics.structures.periodic_table.ChemicalElement): Element for which the indices should</span>
<span class="sd">                                                                                  be returned</span>
<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: An array of indices of the atoms of the given element</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parent_basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent_basis</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">parent_basis</span><span class="o">.</span><span class="n">select_index</span><span class="p">(</span><span class="n">el</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.get_tags"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_tags">[docs]</a>    <span class="k">def</span> <span class="nf">get_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the keys of the stored tags of the structure</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict_keys: Keys of the stored tags</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span></div>

<div class="viewcode-block" id="Atoms.get_pbc"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_pbc">[docs]</a>    <span class="k">def</span> <span class="nf">get_pbc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a boolean array of the periodic boundary conditions along the x, y and z axis respectively</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Boolean array of length 3</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pbc</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_pbc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pbc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pbc</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.set_pbc"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.set_pbc">[docs]</a>    <span class="k">def</span> <span class="nf">set_pbc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the perioic boundary conditions on all three axis</span>

<span class="sd">        Args:</span>
<span class="sd">            value (numpy.ndarray/list): An array of bool type with length 3</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pbc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pbc</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">*</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,)):</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pbc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.convert_element"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.convert_element">[docs]</a>    <span class="k">def</span> <span class="nf">convert_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span> <span class="n">pse</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a string or an atom instance into a ChemicalElement instance</span>

<span class="sd">        Args:</span>
<span class="sd">            el (str/atomistics.structure.atom.Atom): String or atom instance from which the element should</span>
<span class="sd">                                                            be generated</span>
<span class="sd">            pse (atomistics.structure.periodictable.PeriodicTable): PeriodicTable instance from which the element</span>
<span class="sd">                                                                           is generated (optional)</span>

<span class="sd">        Returns:</span>

<span class="sd">            atomistics.structure.periodictable.ChemicalElement: The required chemical element</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_store_elements</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store_elements</span><span class="p">[</span><span class="n">el</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>  <span class="c1"># as symbol</span>
            <span class="n">element</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">pse</span><span class="o">=</span><span class="n">pse</span><span class="p">)</span><span class="o">.</span><span class="n">element</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">Atom</span><span class="p">):</span>
            <span class="n">element</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">element</span>
            <span class="n">el</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">Abbreviation</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">ChemicalElement</span><span class="p">):</span>
            <span class="n">element</span> <span class="o">=</span> <span class="n">el</span>
            <span class="n">el</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">Abbreviation</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown static type to specify a element&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_store_elements</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;species&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">element</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_species</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_species</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_species</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">element</span></div>

<div class="viewcode-block" id="Atoms.get_chemical_formula"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_chemical_formula">[docs]</a>    <span class="k">def</span> <span class="nf">get_chemical_formula</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the chemical formula of structure</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The chemical formula as a string</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">species</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_species_atoms</span><span class="p">()</span>
        <span class="n">formula</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">string_sym</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">species</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">formula</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">string_sym</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">formula</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">string_sym</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">formula</span></div>

<div class="viewcode-block" id="Atoms.get_chemical_indices"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_chemical_indices">[docs]</a>    <span class="k">def</span> <span class="nf">get_chemical_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of chemical indices as ordered in self.species</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: A list of chemical indices</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span></div>

<div class="viewcode-block" id="Atoms.get_atomic_numbers"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_atomic_numbers">[docs]</a>    <span class="k">def</span> <span class="nf">get_atomic_numbers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the atomic numbers of all the atoms in the structure</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: A list of atomic numbers</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">el_lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">AtomicNumber</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">el_lst</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">])</span></div>

<div class="viewcode-block" id="Atoms.get_chemical_symbols"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_chemical_symbols">[docs]</a>    <span class="k">def</span> <span class="nf">get_chemical_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the chemical symbols for all the atoms in the structure</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: A list of chemical symbols</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">el_lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">Abbreviation</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">el_lst</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">])</span></div>

<div class="viewcode-block" id="Atoms.get_parent_symbols"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_parent_symbols">[docs]</a>    <span class="k">def</span> <span class="nf">get_parent_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the chemical symbols for all the atoms in the structure even for user defined elements</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: A list of chemical symbols</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sp_parent_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Parent</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
                <span class="n">sp_parent_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Abbreviation</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sp_parent_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Parent</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sp_parent_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">])</span></div>

<div class="viewcode-block" id="Atoms.get_parent_basis"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_parent_basis">[docs]</a>    <span class="k">def</span> <span class="nf">get_parent_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the basis with all user defined/special elements as the it&#39;s parent</span>

<span class="sd">        Returns:</span>
<span class="sd">            pyiron.atomistics.structure.atoms.Atoms: Structure without any user defined elements</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parent_basis</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">new_species</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">parent_basis</span><span class="o">.</span><span class="n">species</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_species</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Parent</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
                <span class="n">pse</span> <span class="o">=</span> <span class="n">PeriodicTable</span><span class="p">()</span>
                <span class="n">new_species</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pse</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Parent</span><span class="p">)</span>
        <span class="n">sym_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">Abbreviation</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">new_species</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sym_list</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sym_list</span><span class="p">)):</span>
            <span class="n">uni</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">inv_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                <span class="n">sym_list</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">new_species</span> <span class="o">=</span> <span class="n">new_species</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">parent_basis</span><span class="o">.</span><span class="n">set_species</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">new_species</span><span class="p">))</span>
            <span class="n">indices_copy</span> <span class="o">=</span> <span class="n">parent_basis</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ind_ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inv_ind</span><span class="p">):</span>
                <span class="n">indices_copy</span><span class="p">[</span><span class="n">parent_basis</span><span class="o">.</span><span class="n">indices</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind_ind</span>
            <span class="n">parent_basis</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">indices_copy</span>
            <span class="k">return</span> <span class="n">parent_basis</span>
        <span class="n">parent_basis</span><span class="o">.</span><span class="n">set_species</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">new_species</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">parent_basis</span></div>

<div class="viewcode-block" id="Atoms.get_chemical_elements"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_chemical_elements">[docs]</a>    <span class="k">def</span> <span class="nf">get_chemical_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of chemical element instances</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: A list of chemical element instances</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span></div>

<div class="viewcode-block" id="Atoms.get_number_species_atoms"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_number_species_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">get_number_species_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary with the species in the structure and the corresponding count in the structure</span>

<span class="sd">        Returns:</span>
<span class="sd">            collections.OrderedDict: An ordered dictionary with the species and the corresponding count</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="c1"># print &quot;sorted: &quot;, sorted(set(self.elements))</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">())):</span>
            <span class="n">count</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">():</span>
            <span class="n">count</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">count</span></div>

<div class="viewcode-block" id="Atoms.get_species_symbols"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_species_symbols">[docs]</a>    <span class="k">def</span> <span class="nf">get_species_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the symbols of the present species</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: List of the symbols of the species</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">el</span><span class="o">.</span><span class="n">Abbreviation</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">]))</span></div>

<div class="viewcode-block" id="Atoms.get_species_objects"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_species_objects">[docs]</a>    <span class="k">def</span> <span class="nf">get_species_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">el_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span>
        <span class="n">el_sym_lst</span> <span class="o">=</span> <span class="p">{</span><span class="n">el</span><span class="o">.</span><span class="n">Abbreviation</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">el_set</span><span class="p">)}</span>
        <span class="n">el_sorted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_species_symbols</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">el_set</span><span class="p">[</span><span class="n">el_sym_lst</span><span class="p">[</span><span class="n">el</span><span class="p">]]</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">el_sorted</span><span class="p">]</span></div>

<div class="viewcode-block" id="Atoms.get_number_of_species"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_number_of_species">[docs]</a>    <span class="k">def</span> <span class="nf">get_number_of_species</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.get_number_of_degrees_of_freedom"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_number_of_degrees_of_freedom">[docs]</a>    <span class="k">def</span> <span class="nf">get_number_of_degrees_of_freedom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span></div>

<div class="viewcode-block" id="Atoms.get_center_of_mass"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_center_of_mass">[docs]</a>    <span class="k">def</span> <span class="nf">get_center_of_mass</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            com (float): center of mass in A</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">masses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_masses</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;i,ij-&gt;j&quot;</span><span class="p">,</span> <span class="n">masses</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">masses</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.get_masses"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_masses">[docs]</a>    <span class="k">def</span> <span class="nf">get_masses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">el_lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">AtomicMass</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">el_lst</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span></div>

<div class="viewcode-block" id="Atoms.get_masses_dof"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_masses_dof">[docs]</a>    <span class="k">def</span> <span class="nf">get_masses_dof</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_masses</span><span class="p">(),</span> <span class="n">dim</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.get_volume"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_volume">[docs]</a>    <span class="k">def</span> <span class="nf">get_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">per_atom</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            per_atom (bool): True if volume per atom is to be returned</span>

<span class="sd">        Returns:</span>
<span class="sd">            volume (float): Volume in A**3</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">per_atom</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">))</span></div>

<div class="viewcode-block" id="Atoms.get_density"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_density">[docs]</a>    <span class="k">def</span> <span class="nf">get_density</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the density in g/cm^3</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: Density of the structure</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># conv_factor = Ang3_to_cm3/scipi.constants.Avogadro</span>
        <span class="c1"># with Ang3_to_cm3 = 1e24</span>
        <span class="n">conv_factor</span> <span class="o">=</span> <span class="mf">1.660539040427164</span>
        <span class="k">return</span> <span class="n">conv_factor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_masses</span><span class="p">())</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_volume</span><span class="p">()</span></div>

<div class="viewcode-block" id="Atoms.get_scaled_positions"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_scaled_positions">[docs]</a>    <span class="k">def</span> <span class="nf">get_scaled_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the scaled/relative positions</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: The relative positions of the atoms in the supercell</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pbc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">)</span>
        <span class="c1"># check if each side is non-zero even if None values exist in cell</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">non_zero_sides</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">non_zero_sides</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-7</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Only perform the dot product over non zero side (regardless of PBC)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">non_zero_sides</span><span class="p">):</span>
            <span class="n">positions</span><span class="p">[:,</span> <span class="n">non_zero_sides</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
                <span class="s2">&quot;jk,ij-&gt;ik&quot;</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">non_zero_sides</span><span class="p">][:,</span> <span class="n">non_zero_sides</span><span class="p">]),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="n">non_zero_sides</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="c1"># perform the wrapping along the periodic directions only</span>
            <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
                <span class="n">positions</span><span class="p">[:,</span> <span class="n">pbc</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">positions</span><span class="p">[:,</span> <span class="n">pbc</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Scaled positions do not exist for structures without non-zero cell parameters. </span><span class="se">\n</span><span class="s2">&quot;</span>
                          <span class="s2">&quot;Returning cartesian coordinates&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">positions</span></div>

<div class="viewcode-block" id="Atoms.get_number_of_atoms"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_number_of_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">get_number_of_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># assert(len(self) == np.sum(self.get_number_species_atoms().values()))</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.set_absolute"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.set_absolute">[docs]</a>    <span class="k">def</span> <span class="nf">set_absolute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;set_relative is deprecated as of 2020/02/26. It is not guaranteed from v. 0.3&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_scaled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_scaled</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Atoms.set_relative"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.set_relative">[docs]</a>    <span class="k">def</span> <span class="nf">set_relative</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;set_relative is deprecated as of 2020/02/26. It is not guaranteed from v. 0.3&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_scaled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_scaled</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Atoms.center_coordinates_in_unit_cell"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.center_coordinates_in_unit_cell">[docs]</a>    <span class="k">def</span> <span class="nf">center_coordinates_in_unit_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrap atomic coordinates within the supercell as given by a1, a2., a3</span>

<span class="sd">        Args:</span>
<span class="sd">            origin (float):  0 to confine between 0 and 1, -0.5 to confine between -0.5 and 0.5</span>
<span class="sd">            eps (float): Tolerance to detect atoms at cell edges</span>

<span class="sd">        Returns:</span>

<span class="sd">            pyiron.atomistics.structure.atoms.Atoms: Wrapped structure</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_scaled_positions</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">+</span> <span class="n">eps</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">eps</span> <span class="o">+</span> <span class="n">origin</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Atoms.create_line_mode_structure"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.create_line_mode_structure">[docs]</a>    <span class="k">def</span> <span class="nf">create_line_mode_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                   <span class="n">with_time_reversal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                   <span class="n">recipe</span><span class="o">=</span><span class="s1">&#39;hpkot&#39;</span><span class="p">,</span>
                                   <span class="n">threshold</span><span class="o">=</span><span class="mf">1e-07</span><span class="p">,</span>
                                   <span class="n">symprec</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span>
                                   <span class="n">angle_tolerance</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">,</span>
                                   <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses &#39;seekpath&#39; to create a new structure with high symmetry points and path for band structure calculations.</span>

<span class="sd">        Args:</span>
<span class="sd">            with_time_reversal (bool): if False, and the group has no inversion symmetry,</span>
<span class="sd">                additional lines are returned as described in the HPKOT paper.</span>
<span class="sd">            recipe (str): choose the reference publication that defines the special points and paths.</span>
<span class="sd">                Currently, only &#39;hpkot&#39; is implemented.</span>
<span class="sd">            threshold (float): the threshold to use to verify if we are in and edge case</span>
<span class="sd">                (e.g., a tetragonal cell, but a==c). For instance, in the tI lattice, if abs(a-c) &lt; threshold,</span>
<span class="sd">                a EdgeCaseWarning is issued. Note that depending on the bravais lattice,</span>
<span class="sd">                the meaning of the threshold is different (angle, length, …)</span>
<span class="sd">            symprec (float): the symmetry precision used internally by SPGLIB</span>
<span class="sd">            angle_tolerance (float): the angle_tolerance used internally by SPGLIB</span>

<span class="sd">        Returns:</span>
<span class="sd">            pyiron.atomistics.structure.atoms.Atoms: new structure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">input_structure</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">sp_dict</span> <span class="o">=</span> <span class="n">seekpath</span><span class="o">.</span><span class="n">get_path</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="n">input_structure</span><span class="p">,</span>
                                    <span class="n">with_time_reversal</span><span class="o">=</span><span class="n">with_time_reversal</span><span class="p">,</span>
                                    <span class="n">recipe</span><span class="o">=</span><span class="n">recipe</span><span class="p">,</span>
                                    <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
                                    <span class="n">symprec</span><span class="o">=</span><span class="n">symprec</span><span class="p">,</span>
                                    <span class="n">angle_tolerance</span><span class="o">=</span><span class="n">angle_tolerance</span><span class="p">,</span>
                                    <span class="p">)</span>

        <span class="n">original_element_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">Abbreviation</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">]</span>
        <span class="n">element_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">original_element_list</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">sp_dict</span><span class="p">[</span><span class="s2">&quot;primitive_types&quot;</span><span class="p">]]</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">sp_dict</span><span class="p">[</span><span class="s2">&quot;primitive_positions&quot;</span><span class="p">]</span>
        <span class="n">pbc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">sp_dict</span><span class="p">[</span><span class="s2">&quot;primitive_lattice&quot;</span><span class="p">]</span>

        <span class="n">struc_new</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="n">elements</span><span class="o">=</span><span class="n">element_list</span><span class="p">,</span> <span class="n">scaled_positions</span><span class="o">=</span><span class="n">positions</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="n">cell</span><span class="p">)</span>

        <span class="n">struc_new</span><span class="o">.</span><span class="n">_set_high_symmetry_points</span><span class="p">(</span><span class="n">sp_dict</span><span class="p">[</span><span class="s2">&quot;point_coords&quot;</span><span class="p">])</span>
        <span class="n">struc_new</span><span class="o">.</span><span class="n">_set_high_symmetry_path</span><span class="p">({</span><span class="s2">&quot;full&quot;</span><span class="p">:</span> <span class="n">sp_dict</span><span class="p">[</span><span class="s2">&quot;path&quot;</span><span class="p">]})</span>

        <span class="k">return</span> <span class="n">struc_new</span></div>

<div class="viewcode-block" id="Atoms.repeat"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.repeat">[docs]</a>    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rep</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new repeated atoms object.</span>

<span class="sd">        The *rep* argument should be a sequence of three positive</span>
<span class="sd">        integers like *(2,3,1)* or a single integer (*r*) equivalent</span>
<span class="sd">        to *(r,r,r)*.&quot;&quot;&quot;</span>

        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">atoms</span> <span class="o">*=</span> <span class="n">rep</span>
        <span class="k">return</span> <span class="n">atoms</span></div>

<div class="viewcode-block" id="Atoms.set_repeat"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.set_repeat">[docs]</a>    <span class="k">def</span> <span class="nf">set_repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
        <span class="bp">self</span> <span class="o">*=</span> <span class="n">vec</span></div>

<div class="viewcode-block" id="Atoms.repeat_points"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.repeat_points">[docs]</a>    <span class="k">def</span> <span class="nf">repeat_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">rep</span><span class="p">,</span> <span class="n">centered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return points with repetition given according to periodic boundary conditions</span>

<span class="sd">        Args:</span>
<span class="sd">            points (np.ndarray/list): xyz vector or list/array of xyz vectors</span>
<span class="sd">            rep (int/list/np.ndarray): Repetition in each direction.</span>
<span class="sd">                                       If int is given, the same value is used for</span>
<span class="sd">                                       every direction</span>
<span class="sd">            centered (bool): Whether the original points should be in the center of</span>
<span class="sd">                             repeated points.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray) repeated points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rep</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">!=</span><span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;rep must be an integer or a list of 3 integers&#39;</span><span class="p">)</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vector</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;points must be an xyz vector or a list/array of xyz vectors&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">centered</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">!=</span><span class="mi">3</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;When centered, only odd number of repetition should be used&#39;</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">vector</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">n_lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">centered</span><span class="p">:</span>
                <span class="n">n_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nn</span><span class="p">)</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">nn</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nn</span><span class="p">))</span>
        <span class="n">meshgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">n_lst</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n_lst</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">n_lst</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">v_repeated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ni,ij-&gt;nj&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">meshgrid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
        <span class="n">v_repeated</span> <span class="o">=</span> <span class="n">v_repeated</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span><span class="o">+</span><span class="n">v</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="n">v_repeated</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span><span class="o">+</span><span class="n">vector</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.reset_absolute"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.reset_absolute">[docs]</a>    <span class="k">def</span> <span class="nf">reset_absolute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_absolute</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;This function was removed!&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.analyse_ovito_cna_adaptive"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.analyse_ovito_cna_adaptive">[docs]</a>    <span class="k">def</span> <span class="nf">analyse_ovito_cna_adaptive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;total&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use Ovito&#39;s common neighbor analysis binding.</span>

<span class="sd">        Args:</span>
<span class="sd">            mode (&quot;total&quot;/&quot;numeric&quot;/&quot;str&quot;): Controls the style and level of detail of the output. (Default is &quot;total&quot;, only</span>
<span class="sd">                return a summary of the values in the structure.)</span>

<span class="sd">        Returns:</span>
<span class="sd">            (depends on `mode`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pyiron.atomistics.structure.ovito</span> <span class="kn">import</span> <span class="n">analyse_ovito_cna_adaptive</span>
        <span class="k">return</span> <span class="n">analyse_ovito_cna_adaptive</span><span class="p">(</span><span class="n">atoms</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.analyse_ovito_centro_symmetry"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.analyse_ovito_centro_symmetry">[docs]</a>    <span class="k">def</span> <span class="nf">analyse_ovito_centro_symmetry</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="o">=</span><span class="mi">12</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pyiron.atomistics.structure.ovito</span> <span class="kn">import</span> <span class="n">analyse_ovito_centro_symmetry</span>
        <span class="k">return</span> <span class="n">analyse_ovito_centro_symmetry</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="o">=</span><span class="n">num_neighbors</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.analyse_ovito_voronoi_volume"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.analyse_ovito_voronoi_volume">[docs]</a>    <span class="k">def</span> <span class="nf">analyse_ovito_voronoi_volume</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pyiron.atomistics.structure.ovito</span> <span class="kn">import</span> <span class="n">analyse_ovito_voronoi_volume</span>
        <span class="k">return</span> <span class="n">analyse_ovito_voronoi_volume</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.analyse_pyscal_steinhardt_parameter"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.analyse_pyscal_steinhardt_parameter">[docs]</a>    <span class="k">def</span> <span class="nf">analyse_pyscal_steinhardt_parameter</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">3.5</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">]):</span>
        <span class="kn">from</span> <span class="nn">pyiron.atomistics.structure.pyscal</span> <span class="kn">import</span> <span class="n">get_steinhardt_parameter_structure</span>
        <span class="k">return</span> <span class="n">get_steinhardt_parameter_structure</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.analyse_phonopy_equivalent_atoms"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.analyse_phonopy_equivalent_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">analyse_phonopy_equivalent_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pyiron.atomistics.structure.phonopy</span> <span class="kn">import</span> <span class="n">analyse_phonopy_equivalent_atoms</span>

        <span class="c1"># warnings.filterwarnings(&quot;ignore&quot;)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;analyse_phonopy_equivalent_atoms() is obsolete use get_symmetry()[&#39;equivalent_atoms&#39;] instead&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">analyse_phonopy_equivalent_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_ngl_write_cell</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">f1</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">f2</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">f3</span><span class="o">=</span><span class="mi">90</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes a PDB-formatted line to represent the simulation cell.</span>

<span class="sd">        Args:</span>
<span class="sd">            a1, a2, a3 (float): Lengths of the cell vectors.</span>
<span class="sd">            f1, f2, f3 (float): Angles between the cell vectors (which angles exactly?) (in degrees).</span>

<span class="sd">        Returns:</span>
<span class="sd">            (str): The line defining the cell in PDB format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;CRYST1 </span><span class="si">{:8.3f}</span><span class="s2"> </span><span class="si">{:8.3f}</span><span class="s2"> </span><span class="si">{:8.3f}</span><span class="s2"> </span><span class="si">{:6.2f}</span><span class="s2"> </span><span class="si">{:6.2f}</span><span class="s2"> </span><span class="si">{:6.2f}</span><span class="s2"> P 1</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_ngl_write_atom</span><span class="p">(</span>
        <span class="n">num</span><span class="p">,</span>
        <span class="n">species</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">y</span><span class="p">,</span>
        <span class="n">z</span><span class="p">,</span>
        <span class="n">group</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">num2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">occupancy</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">temperature_factor</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes a PDB-formatted line to represent an atom.</span>

<span class="sd">        Args:</span>
<span class="sd">            num (int): Atomic index.</span>
<span class="sd">            species (str): Elemental species.</span>
<span class="sd">            x, y, z (float): Cartesian coordinates of the atom.</span>
<span class="sd">            group (str): A...group name? (Default is None, repeat elemental species.)</span>
<span class="sd">            num2 (int): An &quot;alternate&quot; index. (Don&#39;t ask me...) (Default is None, repeat first number.)</span>
<span class="sd">            occupancy (float): PDB occupancy parameter. (Default is 1.)</span>
<span class="sd">            temperature_factor (float): PDB temperature factor parameter. (Default is 0.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (str): The line defining an atom in PDB format</span>

<span class="sd">        Warnings:</span>
<span class="sd">            * The [PDB docs](https://www.cgl.ucsf.edu/chimera/docs/UsersGuide/tutorials/pdbintro.html) indicate that</span>
<span class="sd">                the xyz coordinates might need to be in some sort of orthogonal basis. If you have weird behaviour,</span>
<span class="sd">                this might be a good place to investigate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">group</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">group</span> <span class="o">=</span> <span class="n">species</span>
        <span class="k">if</span> <span class="n">num2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num2</span> <span class="o">=</span> <span class="n">num</span>
        <span class="k">return</span> <span class="s2">&quot;ATOM </span><span class="si">{:&gt;6}</span><span class="s2"> </span><span class="si">{:&gt;4}</span><span class="s2"> </span><span class="si">{:&gt;4}</span><span class="s2"> </span><span class="si">{:&gt;5}</span><span class="s2"> </span><span class="si">{:10.3f}</span><span class="s2"> </span><span class="si">{:7.3f}</span><span class="s2"> </span><span class="si">{:7.3f}</span><span class="s2"> </span><span class="si">{:5.2f}</span><span class="s2"> </span><span class="si">{:5.2f}</span><span class="s2"> </span><span class="si">{:&gt;11}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">num</span><span class="p">,</span> <span class="n">species</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">num2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">occupancy</span><span class="p">,</span> <span class="n">temperature_factor</span><span class="p">,</span> <span class="n">species</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ngl_write_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">cell</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Turns structure information into a NGLView-readable protein-database-formatted string.</span>

<span class="sd">        Args:</span>
<span class="sd">            elements (numpy.ndarray/list): Element symbol for each atom.</span>
<span class="sd">            positions (numpy.ndarray/list): Vector of Cartesian atom positions.</span>
<span class="sd">            cell (numpy.ndarray/list): Simulation cell Bravais matrix.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (str): The PDB-formatted representation of the structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ase.geometry</span> <span class="kn">import</span> <span class="n">cell_to_cellpar</span><span class="p">,</span> <span class="n">cellpar_to_cell</span>
        <span class="k">if</span> <span class="n">cell</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-2</span><span class="p">):</span>
            <span class="c1"># Define a dummy cell if it doesn&#39;t exist (eg. for clusters)</span>
            <span class="n">max_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">max_pos</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">max_pos</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">max_pos</span>
        <span class="n">cellpar</span> <span class="o">=</span> <span class="n">cell_to_cellpar</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
        <span class="n">exportedcell</span> <span class="o">=</span> <span class="n">cellpar_to_cell</span><span class="p">(</span><span class="n">cellpar</span><span class="p">)</span>
        <span class="n">rotation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">exportedcell</span><span class="p">)</span>

        <span class="n">pdb_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ngl_write_cell</span><span class="p">(</span><span class="o">*</span><span class="n">cellpar</span><span class="p">)</span>
        <span class="n">pdb_str</span> <span class="o">+=</span> <span class="s2">&quot;MODEL     1</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="n">rotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="n">pdb_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ngl_write_atom</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">elements</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>

        <span class="n">pdb_str</span> <span class="o">+=</span> <span class="s2">&quot;ENDMDL </span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">pdb_str</span>

    <span class="k">def</span> <span class="nf">_atomic_number_to_radius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atomic_number</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">slope</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Give the atomic radius for plotting, which scales like the root of the atomic number.</span>

<span class="sd">        Args:</span>
<span class="sd">            atomic_number (int/float): The atomic number.</span>
<span class="sd">            shift (float): A constant addition to the radius. (Default is 0.2.)</span>
<span class="sd">            slope (float): A multiplier for the root of the atomic number. (Default is 0.1)</span>
<span class="sd">            scale (float): How much to rescale the whole thing by.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (float): The radius. (Not physical, just for visualization!)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">shift</span> <span class="o">+</span> <span class="n">slope</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">atomic_number</span><span class="p">))</span> <span class="o">*</span> <span class="n">scale</span>

    <span class="k">def</span> <span class="nf">_add_colorscheme_spacefill</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">atomic_numbers</span><span class="p">,</span> <span class="n">particle_size</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="s2">&quot;element&quot;</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set NGLView spacefill parameters according to a color-scheme.</span>

<span class="sd">        Args:</span>
<span class="sd">            view (NGLWidget): The widget to work on.</span>
<span class="sd">            elements (numpy.ndarray/list): Elemental symbols.</span>
<span class="sd">            atomic_numbers (numpy.ndarray/list): Integer atomic numbers for determining atomic size.</span>
<span class="sd">            particle_size (float): A scale factor for the atomic size.</span>
<span class="sd">            scheme (str): The scheme to use. (Default is &quot;element&quot;.)</span>

<span class="sd">            Possible NGLView color schemes:</span>
<span class="sd">              &quot; &quot;, &quot;picking&quot;, &quot;random&quot;, &quot;uniform&quot;, &quot;atomindex&quot;, &quot;residueindex&quot;,</span>
<span class="sd">              &quot;chainindex&quot;, &quot;modelindex&quot;, &quot;sstruc&quot;, &quot;element&quot;, &quot;resname&quot;, &quot;bfactor&quot;,</span>
<span class="sd">              &quot;hydrophobicity&quot;, &quot;value&quot;, &quot;volume&quot;, &quot;occupancy&quot;</span>

<span class="sd">        Returns:</span>
<span class="sd">            (nglview.NGLWidget): The modified widget.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">elem</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="n">atomic_numbers</span><span class="p">))):</span>
            <span class="n">view</span><span class="o">.</span><span class="n">add_spacefill</span><span class="p">(</span>
                <span class="n">selection</span><span class="o">=</span><span class="s2">&quot;#&quot;</span> <span class="o">+</span> <span class="n">elem</span><span class="p">,</span>
                <span class="n">radius_type</span><span class="o">=</span><span class="s2">&quot;vdw&quot;</span><span class="p">,</span>
                <span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_atomic_number_to_radius</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">particle_size</span><span class="p">),</span>
                <span class="n">color_scheme</span><span class="o">=</span><span class="n">scheme</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">view</span>

    <span class="k">def</span> <span class="nf">_add_custom_color_spacefill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">atomic_numbers</span><span class="p">,</span> <span class="n">particle_size</span><span class="p">,</span> <span class="n">colors</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set NGLView spacefill parameters according to per-atom colors.</span>

<span class="sd">        Args:</span>
<span class="sd">            view (NGLWidget): The widget to work on.</span>
<span class="sd">            atomic_numbers (numpy.ndarray/list): Integer atomic numbers for determining atomic size.</span>
<span class="sd">            particle_size (float): A scale factor for the atomic size.</span>
<span class="sd">            colors (numpy.ndarray/list): A per-atom list of HTML or hex color codes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (nglview.NGLWidget): The modified widget.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atomic_numbers</span><span class="p">):</span>
            <span class="n">view</span><span class="o">.</span><span class="n">add_spacefill</span><span class="p">(</span>
                <span class="n">selection</span><span class="o">=</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                <span class="n">radius_type</span><span class="o">=</span><span class="s2">&quot;vdw&quot;</span><span class="p">,</span>
                <span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_atomic_number_to_radius</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">particle_size</span><span class="p">),</span>
                <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">view</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_scalars_to_hex_colors</span><span class="p">(</span><span class="n">scalar_field</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert scalar values to hex codes using a colormap.</span>

<span class="sd">        Args:</span>
<span class="sd">            scalar_field (numpy.ndarray/list): Scalars to convert.</span>
<span class="sd">            start (float): Scalar value to map to the bottom of the colormap (values below are clipped). (Default is</span>
<span class="sd">                None, use the minimal scalar value.)</span>
<span class="sd">            end (float): Scalar value to map to the top of the colormap (values above are clipped).  (Default is</span>
<span class="sd">                None, use the maximal scalar value.)</span>
<span class="sd">            cmap (matplotlib.cm): The colormap to use. (Default is None, which gives a blue-red divergent map.)</span>

<span class="sd">        Returns:</span>
<span class="sd">            (list): The corresponding hex codes for each scalar value passed in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">scalar_field</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">scalar_field</span><span class="p">)</span>
        <span class="n">interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">([</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">remapped_field</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">scalar_field</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># Map field onto [0,1]</span>

        <span class="k">if</span> <span class="n">cmap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">seaborn</span> <span class="kn">import</span> <span class="n">diverging_palette</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;The package seaborn needs to be installed for the plot3d() function!&quot;</span>
                <span class="p">)</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">diverging_palette</span><span class="p">(</span><span class="mi">245</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="n">as_cmap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># A nice blue-red palette</span>

        <span class="k">return</span> <span class="p">[</span>
            <span class="n">rgb2hex</span><span class="p">(</span><span class="n">cmap</span><span class="p">(</span><span class="n">scalar</span><span class="p">)[:</span><span class="mi">3</span><span class="p">])</span> <span class="k">for</span> <span class="n">scalar</span> <span class="ow">in</span> <span class="n">remapped_field</span>
        <span class="p">]</span>  <span class="c1"># The slice gets RGB but leaves alpha</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_flattened_orientation</span><span class="p">(</span><span class="n">view_plane</span><span class="p">,</span> <span class="n">distance_from_camera</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A helper method to plot3d, which generates a rotation matrix from the input `view_plane`, and returns a</span>
<span class="sd">        flattened list of len = 16. This flattened list becomes the input argument to `view.contol.orient`.</span>

<span class="sd">        Args:</span>
<span class="sd">            view_plane (numpy.ndarray/list): A Nx3-array/list (N = 1,2,3); the first 3d-component of the array</span>
<span class="sd">                specifies which plane of the system to view (for example, [1, 0, 0], [1, 1, 0] or the [1, 1, 1] planes),</span>
<span class="sd">                the second 3d-component (if specified, otherwise [1, 0, 0]) gives the horizontal direction, and the</span>
<span class="sd">                third component (if specified) is the vertical component, which is ignored and calculated internally.</span>
<span class="sd">                The orthonormality of the orientation is internally ensured, and therefore is not required in the</span>
<span class="sd">                function call.</span>
<span class="sd">            distance_from_camera (float): Distance of the camera from the structure. Higher = farther away.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (list): Flattened list of len = 16, which is the input argument to `view.contol.orient`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">view_plane</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The shape of view plane should be (N, 3), where N = 1, 2 or 3. Refer docs for more info.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">distance_from_camera</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;´distance_from_camera´ must be a positive float!&quot;</span><span class="p">)</span>
        <span class="n">view_plane</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">view_plane</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">rotation_matrix</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">view_plane</span><span class="p">)]</span> <span class="o">=</span> <span class="n">view_plane</span>
        <span class="n">rotation_matrix</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rotation_matrix</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">rotation_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotation_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rotation_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">rotation_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Gran-Schmidt</span>
        <span class="n">rotation_matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">rotation_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rotation_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Specify third axis</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">rotation_matrix</span><span class="p">),</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># view_plane = [0,0,1] is the default view of NGLview, so we do not modify it</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">rotation_matrix</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rotation_matrix</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">flattened_orientation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">flattened_orientation</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">rotation_matrix</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">distance_from_camera</span> <span class="o">*</span> <span class="n">flattened_orientation</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

<div class="viewcode-block" id="Atoms.plot3d"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.plot3d">[docs]</a>    <span class="k">def</span> <span class="nf">plot3d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">show_cell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">show_axes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">camera</span><span class="o">=</span><span class="s2">&quot;orthographic&quot;</span><span class="p">,</span>
        <span class="n">spacefill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">particle_size</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">select_atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">background</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">,</span>
        <span class="n">color_scheme</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">scalar_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">scalar_start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">scalar_end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">scalar_cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">vector_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">vector_color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">magnetic_moments</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">custom_array</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">custom_3darray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">view_plane</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
        <span class="n">distance_from_camera</span><span class="o">=</span><span class="mf">14.0</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot3d relies on NGLView to visualize atomic structures. Here, we construct a string in the &quot;protein database&quot;</span>
<span class="sd">        (&quot;pdb&quot;) format, then turn it into an NGLView &quot;structure&quot;. PDB is a white-space sensitive format, so the</span>
<span class="sd">        string snippets are carefully formatted.</span>

<span class="sd">        The final widget is returned. If it is assigned to a variable, the visualization is suppressed until that</span>
<span class="sd">        variable is evaluated, and in the meantime more NGL operations can be applied to it to modify the visualization.</span>

<span class="sd">        Args:</span>
<span class="sd">            show_cell (bool): Whether or not to show the frame. (Default is True.)</span>
<span class="sd">            show_axes (bool): Whether or not to show xyz axes. (Default is True.)</span>
<span class="sd">            camera (str): &#39;perspective&#39; or &#39;orthographic&#39;. (Default is &#39;perspective&#39;.)</span>
<span class="sd">            spacefill (bool): Whether to use a space-filling or ball-and-stick representation. (Default is True, use</span>
<span class="sd">                space-filling atoms.)</span>
<span class="sd">            particle_size (float): Size of the particles. (Default is 1.)</span>
<span class="sd">            select_atoms (numpy.ndarray): Indices of atoms to show, either as integers or a boolean array mask.</span>
<span class="sd">                (Default is None, show all atoms.)</span>
<span class="sd">            background (str): Background color. (Default is &#39;white&#39;.)</span>
<span class="sd">            color_scheme (str): NGLView color scheme to use. (Default is None, color by element.)</span>
<span class="sd">            colors (numpy.ndarray): A per-atom array of HTML color names or hex color codes to use for atomic colors.</span>
<span class="sd">                (Default is None, use coloring scheme.)</span>
<span class="sd">            scalar_field (numpy.ndarray): Color each atom according to the array value (Default is None, use coloring</span>
<span class="sd">                scheme.)</span>
<span class="sd">            scalar_start (float): The scalar value to be mapped onto the low end of the color map (lower values are</span>
<span class="sd">                clipped). (Default is None, use the minimum value in `scalar_field`.)</span>
<span class="sd">            scalar_end (float): The scalar value to be mapped onto the high end of the color map (higher values are</span>
<span class="sd">                clipped). (Default is None, use the maximum value in `scalar_field`.)</span>
<span class="sd">            scalar_cmap (matplotlib.cm): The colormap to use. (Default is None, giving a blue-red divergent map.)</span>
<span class="sd">            vector_field (numpy.ndarray): Add vectors (3 values) originating at each atom. (Default is None, no</span>
<span class="sd">                vectors.)</span>
<span class="sd">            vector_color (numpy.ndarray): Colors for the vectors (only available with vector_field). (Default is None,</span>
<span class="sd">                vectors are colored by their direction.)</span>
<span class="sd">            magnetic_moments (bool): Plot magnetic moments as &#39;scalar_field&#39; or &#39;vector_field&#39;.</span>
<span class="sd">            view_plane (numpy.ndarray): A Nx3-array (N = 1,2,3); the first 3d-component of the array specifies</span>
<span class="sd">                which plane of the system to view (for example, [1, 0, 0], [1, 1, 0] or the [1, 1, 1] planes), the</span>
<span class="sd">                second 3d-component (if specified, otherwise [1, 0, 0]) gives the horizontal direction, and the third</span>
<span class="sd">                component (if specified) is the vertical component, which is ignored and calculated internally. The</span>
<span class="sd">                orthonormality of the orientation is internally ensured, and therefore is not required in the function</span>
<span class="sd">                call. (Default is np.array([0, 0, 1]), which is view normal to the x-y plane.)</span>
<span class="sd">            distance_from_camera (float): Distance of the camera from the structure. Higher = farther away.</span>
<span class="sd">                (Default is 14, which also seems to be the NGLView default value.)</span>

<span class="sd">            Possible NGLView color schemes:</span>
<span class="sd">              &quot; &quot;, &quot;picking&quot;, &quot;random&quot;, &quot;uniform&quot;, &quot;atomindex&quot;, &quot;residueindex&quot;,</span>
<span class="sd">              &quot;chainindex&quot;, &quot;modelindex&quot;, &quot;sstruc&quot;, &quot;element&quot;, &quot;resname&quot;, &quot;bfactor&quot;,</span>
<span class="sd">              &quot;hydrophobicity&quot;, &quot;value&quot;, &quot;volume&quot;, &quot;occupancy&quot;</span>

<span class="sd">        Returns:</span>
<span class="sd">            (nglview.NGLWidget): The NGLView widget itself, which can be operated on further or viewed as-is.</span>

<span class="sd">        Warnings:</span>
<span class="sd">            * Many features only work with space-filling atoms (e.g. coloring by a scalar field).</span>
<span class="sd">            * The colour interpretation of some hex codes is weird, e.g. &#39;green&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>  <span class="c1"># If the graphical packages are not available, the GUI will not work.</span>
            <span class="kn">import</span> <span class="nn">nglview</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                <span class="s2">&quot;The package nglview needs to be installed for the plot3d() function!&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">custom_array</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;custom_array is deprecated. Use scalar_field instead&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">scalar_field</span> <span class="o">=</span> <span class="n">custom_array</span>

        <span class="k">if</span> <span class="n">custom_3darray</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;custom_3darray is deprecated. Use vector_field instead&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">vector_field</span> <span class="o">=</span> <span class="n">custom_3darray</span>

        <span class="k">if</span> <span class="n">magnetic_moments</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;spin&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_initial_magnetic_moments</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">scalar_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_initial_magnetic_moments</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vector_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_initial_magnetic_moments</span><span class="p">()</span>

        <span class="n">parent_basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent_basis</span><span class="p">()</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="n">parent_basis</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()</span>
        <span class="n">atomic_numbers</span> <span class="o">=</span> <span class="n">parent_basis</span><span class="o">.</span><span class="n">get_atomic_numbers</span><span class="p">()</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span>

        <span class="c1"># If `select_atoms` was given, visualize only a subset of the `parent_basis`</span>
        <span class="k">if</span> <span class="n">select_atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">select_atoms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">select_atoms</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">elements</span> <span class="o">=</span> <span class="n">elements</span><span class="p">[</span><span class="n">select_atoms</span><span class="p">]</span>
            <span class="n">atomic_numbers</span> <span class="o">=</span> <span class="n">atomic_numbers</span><span class="p">[</span><span class="n">select_atoms</span><span class="p">]</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="n">select_atoms</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
                <span class="n">colors</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="n">select_atoms</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">scalar_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">scalar_field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scalar_field</span><span class="p">)</span>
                <span class="n">scalar_field</span> <span class="o">=</span> <span class="n">scalar_field</span><span class="p">[</span><span class="n">select_atoms</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">vector_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vector_field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vector_field</span><span class="p">)</span>
                <span class="n">vector_field</span> <span class="o">=</span> <span class="n">vector_field</span><span class="p">[</span><span class="n">select_atoms</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">vector_color</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vector_color</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vector_color</span><span class="p">)</span>
                <span class="n">vector_color</span> <span class="o">=</span> <span class="n">vector_color</span><span class="p">[</span><span class="n">select_atoms</span><span class="p">]</span>

        <span class="c1"># Write the nglview protein-database-formatted string</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="n">nglview</span><span class="o">.</span><span class="n">TextStructure</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ngl_write_structure</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Parse the string into the displayable widget</span>
        <span class="n">view</span> <span class="o">=</span> <span class="n">nglview</span><span class="o">.</span><span class="n">NGLWidget</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">spacefill</span><span class="p">:</span>
            <span class="c1"># Color by scheme</span>
            <span class="k">if</span> <span class="n">color_scheme</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;`color_scheme` is overriding `colors`&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">scalar_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;`color_scheme` is overriding `scalar_field`&quot;</span><span class="p">)</span>
                <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_colorscheme_spacefill</span><span class="p">(</span>
                    <span class="n">view</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">atomic_numbers</span><span class="p">,</span> <span class="n">particle_size</span><span class="p">,</span> <span class="n">color_scheme</span>
                <span class="p">)</span>
            <span class="c1"># Color by per-atom colors</span>
            <span class="k">elif</span> <span class="n">colors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">scalar_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;`colors` is overriding `scalar_field`&quot;</span><span class="p">)</span>
                <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_custom_color_spacefill</span><span class="p">(</span>
                    <span class="n">view</span><span class="p">,</span> <span class="n">atomic_numbers</span><span class="p">,</span> <span class="n">particle_size</span><span class="p">,</span> <span class="n">colors</span>
                <span class="p">)</span>
            <span class="c1"># Color by per-atom scalars</span>
            <span class="k">elif</span> <span class="n">scalar_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Color by per-atom scalars</span>
                <span class="n">colors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scalars_to_hex_colors</span><span class="p">(</span>
                    <span class="n">scalar_field</span><span class="p">,</span> <span class="n">scalar_start</span><span class="p">,</span> <span class="n">scalar_end</span><span class="p">,</span> <span class="n">scalar_cmap</span>
                <span class="p">)</span>
                <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_custom_color_spacefill</span><span class="p">(</span>
                    <span class="n">view</span><span class="p">,</span> <span class="n">atomic_numbers</span><span class="p">,</span> <span class="n">particle_size</span><span class="p">,</span> <span class="n">colors</span>
                <span class="p">)</span>
            <span class="c1"># Color by element</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_colorscheme_spacefill</span><span class="p">(</span>
                    <span class="n">view</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">atomic_numbers</span><span class="p">,</span> <span class="n">particle_size</span>
                <span class="p">)</span>
            <span class="n">view</span><span class="o">.</span><span class="n">remove_ball_and_stick</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">view</span><span class="o">.</span><span class="n">add_ball_and_stick</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">show_cell</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">parent_basis</span><span class="o">.</span><span class="n">cell</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">parent_basis</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-2</span><span class="p">):</span>
                    <span class="n">view</span><span class="o">.</span><span class="n">add_unitcell</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">vector_color</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">vector_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vector_color</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mf">0.5</span>
                <span class="o">*</span> <span class="n">vector_field</span>
                <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vector_field</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="o">+</span> <span class="mf">0.5</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">vector_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">vector_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>  <span class="c1"># WARNING: There must be a bug here...</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">vector_color</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="n">vector_color</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span> <span class="n">vector_color</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vector_color</span><span class="p">)</span>
                    <span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">vector_color</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span> <span class="o">*</span> <span class="n">vector_color</span>

        <span class="k">if</span> <span class="n">vector_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">arr</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vector_field</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">vector_color</span><span class="p">):</span>
                <span class="n">view</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">add_arrow</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">arr</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">col</span><span class="p">),</span> <span class="mf">0.2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">show_axes</span><span class="p">:</span>  <span class="c1"># Add axes</span>
            <span class="n">axes_origin</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">arrow_radius</span> <span class="o">=</span> <span class="mf">0.1</span>
            <span class="n">text_size</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">text_color</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">arrow_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">axes_origin</span><span class="p">)</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
                <span class="n">shift</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">end</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">shift</span><span class="p">)</span>
                <span class="n">color</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>
                <span class="c1"># We cast as list to avoid JSON warnings</span>
                <span class="n">view</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">add_arrow</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">arrow_radius</span><span class="p">)</span>
                <span class="n">view</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">text_color</span><span class="p">,</span> <span class="n">text_size</span><span class="p">,</span> <span class="n">arrow_names</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">camera</span> <span class="o">!=</span> <span class="s2">&quot;perspective&quot;</span> <span class="ow">and</span> <span class="n">camera</span> <span class="o">!=</span> <span class="s2">&quot;orthographic&quot;</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Only perspective or orthographic is (likely to be) permitted for camera&quot;</span>
            <span class="p">)</span>

        <span class="n">view</span><span class="o">.</span><span class="n">camera</span> <span class="o">=</span> <span class="n">camera</span>
        <span class="n">view</span><span class="o">.</span><span class="n">background</span> <span class="o">=</span> <span class="n">background</span>

        <span class="n">orientation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_flattened_orientation</span><span class="p">(</span><span class="n">view_plane</span><span class="o">=</span><span class="n">view_plane</span><span class="p">,</span>
                                                      <span class="n">distance_from_camera</span><span class="o">=</span><span class="n">distance_from_camera</span><span class="p">)</span>
        <span class="n">view</span><span class="o">.</span><span class="n">control</span><span class="o">.</span><span class="n">orient</span><span class="p">(</span><span class="n">orientation</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">view</span></div>

<div class="viewcode-block" id="Atoms.plot3d_ase"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.plot3d_ase">[docs]</a>    <span class="k">def</span> <span class="nf">plot3d_ase</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">spacefill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">show_cell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">camera</span><span class="o">=</span><span class="s2">&quot;perspective&quot;</span><span class="p">,</span>
        <span class="n">particle_size</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">background</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">,</span>
        <span class="n">color_scheme</span><span class="o">=</span><span class="s2">&quot;element&quot;</span><span class="p">,</span>
        <span class="n">show_axes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Possible color schemes:</span>
<span class="sd">          &quot; &quot;, &quot;picking&quot;, &quot;random&quot;, &quot;uniform&quot;, &quot;atomindex&quot;, &quot;residueindex&quot;,</span>
<span class="sd">          &quot;chainindex&quot;, &quot;modelindex&quot;, &quot;sstruc&quot;, &quot;element&quot;, &quot;resname&quot;, &quot;bfactor&quot;,</span>
<span class="sd">          &quot;hydrophobicity&quot;, &quot;value&quot;, &quot;volume&quot;, &quot;occupancy&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>  <span class="c1"># If the graphical packages are not available, the GUI will not work.</span>
            <span class="kn">import</span> <span class="nn">nglview</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                <span class="s2">&quot;The package nglview needs to be installed for the plot3d() function!&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Always visualize the parent basis</span>
        <span class="n">parent_basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent_basis</span><span class="p">()</span>
        <span class="n">view</span> <span class="o">=</span> <span class="n">nglview</span><span class="o">.</span><span class="n">show_ase</span><span class="p">(</span><span class="n">parent_basis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">spacefill</span><span class="p">:</span>
            <span class="n">view</span><span class="o">.</span><span class="n">add_spacefill</span><span class="p">(</span>
                <span class="n">radius_type</span><span class="o">=</span><span class="s2">&quot;vdw&quot;</span><span class="p">,</span> <span class="n">color_scheme</span><span class="o">=</span><span class="n">color_scheme</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">particle_size</span>
            <span class="p">)</span>
            <span class="c1"># view.add_spacefill(radius=1.0)</span>
            <span class="n">view</span><span class="o">.</span><span class="n">remove_ball_and_stick</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">view</span><span class="o">.</span><span class="n">add_ball_and_stick</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">show_cell</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">parent_basis</span><span class="o">.</span><span class="n">cell</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">parent_basis</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-2</span><span class="p">):</span>
                    <span class="n">view</span><span class="o">.</span><span class="n">add_unitcell</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">show_axes</span><span class="p">:</span>
            <span class="n">view</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">add_arrow</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="n">view</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">add_arrow</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="n">view</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">add_arrow</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">camera</span> <span class="o">!=</span> <span class="s2">&quot;perspective&quot;</span> <span class="ow">and</span> <span class="n">camera</span> <span class="o">!=</span> <span class="s2">&quot;orthographic&quot;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Only perspective or orthographic is permitted&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">view</span><span class="o">.</span><span class="n">camera</span> <span class="o">=</span> <span class="n">camera</span>
        <span class="n">view</span><span class="o">.</span><span class="n">background</span> <span class="o">=</span> <span class="n">background</span>
        <span class="k">return</span> <span class="n">view</span></div>

<div class="viewcode-block" id="Atoms.pos_xyz"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.pos_xyz">[docs]</a>    <span class="k">def</span> <span class="nf">pos_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span></div>

<div class="viewcode-block" id="Atoms.scaled_pos_xyz"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.scaled_pos_xyz">[docs]</a>    <span class="k">def</span> <span class="nf">scaled_pos_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">xyz</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">xyz</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">xyz</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">__select_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i_dim</span><span class="p">,</span> <span class="n">i_flag</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            i_dim:</span>
<span class="sd">            i_flag:</span>
<span class="sd">            dist:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">i_dim</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">i_flag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">)[:,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dist</span>
        <span class="k">elif</span> <span class="n">i_flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">i_flag</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">)[:,</span> <span class="n">i_dim</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">dist</span>

<div class="viewcode-block" id="Atoms.get_boundary_region"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_boundary_region">[docs]</a>    <span class="k">def</span> <span class="nf">get_boundary_region</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get all atoms in the boundary around the supercell which have a distance</span>
<span class="sd">        to the supercell boundary of less than dist</span>

<span class="sd">        Args:</span>
<span class="sd">            dist:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rel_coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># to use same definition as ASE</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">min_i</span><span class="p">,</span> <span class="n">max_i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
        <span class="n">iyl</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">izl</span><span class="p">,</span> <span class="n">iz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">a2</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">iyl</span><span class="p">,</span> <span class="n">iy</span> <span class="o">=</span> <span class="n">min_i</span><span class="p">,</span> <span class="n">max_i</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">a3</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">izl</span><span class="p">,</span> <span class="n">iz</span> <span class="o">=</span> <span class="n">min_i</span><span class="p">,</span> <span class="n">max_i</span>

        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">new_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
        <span class="c1"># pbcVec = np.zeros((1, dim))</span>
        <span class="n">ia_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_i</span><span class="p">,</span> <span class="n">max_i</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iyl</span><span class="p">,</span> <span class="n">iy</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">izl</span><span class="p">,</span> <span class="n">iz</span><span class="p">):</span>
                    <span class="c1"># r_vec_abs = i0 * a1 + i1 * a2 + i2 * a3</span>
                    <span class="n">r_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">][:</span><span class="n">dim</span><span class="p">])</span>
                    <span class="n">select</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__select_slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i0</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span>
                        <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">__select_slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span>
                        <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">__select_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">r_vec</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">select</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">sel_coordinates</span> <span class="o">=</span> <span class="n">rel_coordinates</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">+</span> <span class="n">r_vec</span>
                            <span class="n">new_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="n">new_coordinates</span><span class="p">,</span> <span class="n">sel_coordinates</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                            <span class="p">)</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel_coordinates</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="c1"># rVecs = np.array(len(sel_coordinates) * [r_vec_abs])</span>
                                <span class="c1"># pbcVec = np.append(pbcVec, rVecs, axis=0)</span>
                                <span class="n">ia_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ia_list</span><span class="p">,</span> <span class="n">index</span><span class="p">[</span><span class="n">select</span><span class="p">])</span>
                                <span class="c1"># print &quot;rVec: &quot;, i0,i1,i2,rVecs[0],index[select],select</span>

        <span class="n">element_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span> <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">ia_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ia_bounds</span> <span class="o">=</span> <span class="n">ia_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="c1"># self._pbcVec = pbcVec[1:]</span>
        <span class="k">return</span> <span class="n">Atoms</span><span class="p">(</span>
            <span class="n">indices</span><span class="o">=</span><span class="n">element_list</span><span class="p">,</span>
            <span class="n">scaled_positions</span><span class="o">=</span><span class="n">new_coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
            <span class="n">cell</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span>
            <span class="n">dimension</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="p">),</span>
            <span class="n">species</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.get_neighbors"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_neighbors">[docs]</a>    <span class="k">def</span> <span class="nf">get_neighbors</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">num_neighbors</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
        <span class="n">t_vec</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">include_boundary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">exclude_self</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">id_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cutoff_radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            num_neighbors (int): number of neighbors</span>
<span class="sd">            t_vec (bool): True: compute distance vectors</span>
<span class="sd">                        (pbc are automatically taken into account)</span>
<span class="sd">            include_boundary (bool): True: search for neighbors assuming periodic boundary conditions</span>
<span class="sd">                                     False is needed e.g. in plot routines to avoid showing incorrect bonds</span>
<span class="sd">            exclude_self (bool): include central __atom (i.e. distance = 0)</span>
<span class="sd">            tolerance (int): tolerance (round decimal points) used for computing neighbor shells</span>
<span class="sd">            id_list:</span>
<span class="sd">            cutoff (float/None): Upper bound of the distance to which the search must be done - by default search for</span>
<span class="sd">                                 upto 100 neighbors unless num_neighbors is defined explicitly.</span>
<span class="sd">            cutoff_radius (float/None): Upper bound of the distance to which the search must be done - by default search</span>
<span class="sd">                                        for upto 100 neighbors unless num_neighbors is defined explicitly.</span>

<span class="sd">        Returns:</span>

<span class="sd">            pyiron.atomistics.structure.atoms.Neighbors: Neighbors instances with the neighbor indices, distances</span>
<span class="sd">            and vectors</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cutoff_radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Please use cutoff_radius, rather than cutoff&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span>
            <span class="p">)</span>
            <span class="n">cutoff_radius</span> <span class="o">=</span> <span class="n">cutoff</span>
        <span class="k">if</span> <span class="n">cutoff_radius</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">num_neighbors</span> <span class="o">==</span> <span class="mi">12</span><span class="p">:</span>
            <span class="n">num_neighbors</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="c1"># eps = 1e-4</span>
        <span class="n">i_start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">exclude_self</span><span class="p">:</span>
            <span class="n">i_start</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">def</span> <span class="nf">f_ind</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">num_neighbors</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">neighbor_obj</span> <span class="o">=</span> <span class="n">Neighbors</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">include_boundary</span><span class="p">:</span>  <span class="c1"># periodic boundaries are NOT included</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cutoff_radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">neighbors</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">num_neighbors</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">neighbors</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">num_neighbors</span><span class="p">,</span> <span class="n">distance_upper_bound</span><span class="o">=</span><span class="n">cutoff_radius</span>
                <span class="p">)</span>

            <span class="n">d_lst</span><span class="p">,</span> <span class="n">ind_lst</span><span class="p">,</span> <span class="n">v_lst</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="n">ic</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">d_i</span><span class="p">,</span> <span class="n">ind_i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">neighbors</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">ff</span> <span class="o">=</span> <span class="p">(</span><span class="n">ind_i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ind_i</span> <span class="o">!=</span> <span class="n">ic</span><span class="p">)</span>
                <span class="n">ind_l</span> <span class="o">=</span> <span class="n">ind_i</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span>
                <span class="n">ind_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind_l</span><span class="p">)</span>
                <span class="n">d_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d_i</span><span class="p">[</span><span class="n">ff</span><span class="p">])</span>
                <span class="n">v_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">ind_l</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">ic</span><span class="p">])</span>
                <span class="n">ic</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">neighbor_obj</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">ind_lst</span>
            <span class="n">neighbor_obj</span><span class="o">.</span><span class="n">distances</span> <span class="o">=</span> <span class="n">d_lst</span>
            <span class="n">neighbor_obj</span><span class="o">.</span><span class="n">vecs</span> <span class="o">=</span> <span class="n">v_lst</span>
            <span class="k">return</span> <span class="n">neighbor_obj</span>

        <span class="c1"># include periodic boundaries</span>
        <span class="c1"># translate radius in boundary layer with relative coordinates</span>
        <span class="c1"># TODO: introduce more rigoros definition</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">num_neighbors</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span>
        <span class="n">rel_width</span> <span class="o">=</span> <span class="p">[</span><span class="n">radius</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a_i</span><span class="p">,</span> <span class="n">a_i</span><span class="p">))</span> <span class="k">for</span> <span class="n">a_i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">]</span>
        <span class="n">rel_width_scalar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rel_width</span><span class="p">)</span>

        <span class="c1"># construct cell with additional atoms bounding original cell</span>
        <span class="n">boundary_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_boundary_region</span><span class="p">(</span><span class="n">rel_width_scalar</span><span class="p">)</span>
        <span class="n">extended_cell</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">boundary_atoms</span>

        <span class="c1"># build index to map boundary atoms back to original cell</span>
        <span class="n">map_to_cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ia_bounds</span><span class="p">)</span>

        <span class="c1"># transfer relative to absolute coordinates</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">extended_cell</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">id_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">id_list</span><span class="p">])</span>
        <span class="c1"># print (&quot;len positions: &quot;, len(positions))</span>
        <span class="k">if</span> <span class="n">cutoff_radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">num_neighbors</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
                <span class="n">positions</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">num_neighbors</span><span class="p">,</span> <span class="n">distance_upper_bound</span><span class="o">=</span><span class="n">cutoff_radius</span>
            <span class="p">)</span>

        <span class="c1"># print (&quot;neighbors: &quot;, neighbors)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">neighbor_distance</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># neighbors[0]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neighbor_distance_vec</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neighbor_index</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">neighbor_shellOrder</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># tolerance = 2 # tolerance for round floating point</span>

        <span class="k">def</span> <span class="nf">f_ind_ext</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">extended_cell</span><span class="p">)</span>

        <span class="n">neighbor_index</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">filter</span><span class="p">(</span><span class="n">f_ind_ext</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">neighbors</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">num_neighbors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neighbor_index</span><span class="p">):</span>
            <span class="c1"># print &quot;i, index: &quot;, i, index</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>  <span class="c1"># Filter conversion for python 3 compatibility</span>
            <span class="n">nbrs_distances</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">i_start</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span>
            <span class="c1"># if radius:  # reduce neighborlist based on radius</span>
            <span class="c1">#     new_index_lst, new_dist_lst = [], []</span>
            <span class="c1">#     for index_red, dis_red in zip(index, nbrs_distances):</span>
            <span class="c1">#         if dis_red &lt; radius:</span>
            <span class="c1">#             new_index_lst.append(index_red)</span>
            <span class="c1">#             new_dist_lst.append(dis_red)</span>
            <span class="c1">#     index, nbrs_distances= new_index_lst, new_dist_lst</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neighbor_distance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nbrs_distances</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neighbor_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">map_to_cell</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">i_start</span><span class="p">:])</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">nbrs_distances</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">tolerance</span><span class="p">),</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neighbor_shellOrder</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">indices</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">)</span>  <span class="c1"># this gives the shellOrder of neighboring atoms back</span>

            <span class="k">if</span> <span class="n">t_vec</span><span class="p">:</span>
                <span class="n">nbr_dist</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">neighbor_distance_vec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nbr_dist</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="n">vec0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">i_nbr</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="n">i_start</span><span class="p">:]):</span>
                    <span class="c1"># ind0 = map_to_cell[ind]</span>
                    <span class="n">vec_r_ij</span> <span class="o">=</span> <span class="n">extended_cell</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">-</span> <span class="n">vec0</span>

                    <span class="n">dd0</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">i_nbr</span> <span class="o">+</span> <span class="n">i_start</span><span class="p">]</span>
                    <span class="n">dd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_r_ij</span><span class="p">,</span> <span class="n">vec_r_ij</span><span class="p">))</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">dd</span> <span class="o">-</span> <span class="n">dd0</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">()</span>
                    <span class="c1"># if (dd - dd0 &gt; 0.001):</span>
                    <span class="c1">#     print &quot;wrong: &quot;, vec_r_ij, dd,dd0,i_nbr,ind,ind0,i</span>
                    <span class="c1">#     print self.positions[ind0], extended_cell.positions[ind], vec0</span>
                    <span class="n">nbr_dist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vec_r_ij</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">neighbor_distance_vec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nbr_dist</span><span class="p">)</span>
            <span class="n">num_neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">-</span> <span class="n">i_start</span><span class="p">)</span>

        <span class="n">min_nbr</span><span class="p">,</span> <span class="n">max_nbr</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">num_neighbors</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">num_neighbors</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">max_nbr</span> <span class="o">==</span> <span class="n">num_neighbors</span><span class="p">:</span>
            <span class="c1"># print &quot;neighbor distance: &quot;, self.neighbor_distance</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Increase max_num_neighbors! &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">max_nbr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_neighbors</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_nbr_number</span> <span class="o">=</span> <span class="n">min_nbr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_nbr_number</span> <span class="o">=</span> <span class="n">max_nbr</span>
        <span class="n">neighbor_obj</span><span class="o">.</span><span class="n">distances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbor_distance</span>
        <span class="n">neighbor_obj</span><span class="o">.</span><span class="n">vecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbor_distance_vec</span>
        <span class="n">neighbor_obj</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbor_index</span>
        <span class="n">neighbor_obj</span><span class="o">.</span><span class="n">shells</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbor_shellOrder</span>
        <span class="k">return</span> <span class="n">neighbor_obj</span></div>

<div class="viewcode-block" id="Atoms.get_neighborhood"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_neighborhood">[docs]</a>    <span class="k">def</span> <span class="nf">get_neighborhood</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">position</span><span class="p">,</span>
        <span class="n">num_neighbors</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
        <span class="n">t_vec</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">include_boundary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">id_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cutoff_radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            position: position in a box whose neighborhood information is analysed</span>
<span class="sd">            num_neighbors:</span>
<span class="sd">            t_vec (bool): True: compute distance vectors</span>
<span class="sd">                        (pbc are automatically taken into account)</span>
<span class="sd">            include_boundary (bool): True: search for neighbors assuming periodic boundary conditions</span>
<span class="sd">                                     False is needed e.g. in plot routines to avoid showing incorrect bonds</span>
<span class="sd">            tolerance (int): tolerance (round decimal points) used for computing neighbor shells</span>
<span class="sd">            id_list:</span>
<span class="sd">            cutoff (float/ None): Upper bound of the distance to which the search must be done</span>
<span class="sd">            cutoff_radius (float/ None): Upper bound of the distance to which the search must be done</span>

<span class="sd">        Returns:</span>

<span class="sd">            pyiron.atomistics.structure.atoms.Neighbors: Neighbors instances with the neighbor indices, distances</span>
<span class="sd">            and vectors</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">class</span> <span class="nc">NeighTemp</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">box</span> <span class="o">+=</span> <span class="n">box</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">box</span><span class="o">.</span><span class="n">positions</span>
        <span class="n">pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
        <span class="n">box</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="n">neigh</span> <span class="o">=</span> <span class="n">box</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span>
            <span class="n">num_neighbors</span><span class="o">=</span><span class="n">num_neighbors</span><span class="p">,</span>
            <span class="n">t_vec</span><span class="o">=</span><span class="n">t_vec</span><span class="p">,</span>
            <span class="n">include_boundary</span><span class="o">=</span><span class="n">include_boundary</span><span class="p">,</span>
            <span class="n">exclude_self</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
            <span class="n">id_list</span><span class="o">=</span><span class="n">id_list</span><span class="p">,</span>
            <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">,</span>
            <span class="n">cutoff_radius</span><span class="o">=</span><span class="n">cutoff_radius</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">neigh_return</span> <span class="o">=</span> <span class="n">NeighTemp</span><span class="p">()</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">neigh_return</span><span class="p">,</span> <span class="s2">&quot;distances&quot;</span><span class="p">,</span> <span class="n">neigh</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">neigh_return</span><span class="p">,</span> <span class="s2">&quot;shells&quot;</span><span class="p">,</span> <span class="n">neigh</span><span class="o">.</span><span class="n">shells</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">neigh_return</span><span class="p">,</span> <span class="s2">&quot;vecs&quot;</span><span class="p">,</span> <span class="n">neigh</span><span class="o">.</span><span class="n">vecs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">neigh_return</span><span class="p">,</span> <span class="s2">&quot;indices&quot;</span><span class="p">,</span> <span class="n">neigh</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">neigh_return</span><span class="o">.</span><span class="n">distances</span> <span class="o">=</span> <span class="n">neigh_return</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span>
            <span class="n">neigh_return</span><span class="o">.</span><span class="n">indices</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">box</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">]</span>
        <span class="n">neigh_return</span><span class="o">.</span><span class="n">shells</span> <span class="o">=</span> <span class="n">neigh_return</span><span class="o">.</span><span class="n">shells</span><span class="p">[</span><span class="n">neigh_return</span><span class="o">.</span><span class="n">indices</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">box</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">neigh_return</span><span class="o">.</span><span class="n">vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neigh_return</span><span class="o">.</span><span class="n">vecs</span><span class="p">)[</span>
            <span class="n">neigh_return</span><span class="o">.</span><span class="n">indices</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">box</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">]</span>
        <span class="n">neigh_return</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">neigh_return</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span>
            <span class="n">neigh_return</span><span class="o">.</span><span class="n">indices</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">box</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">neigh_return</span></div>

<div class="viewcode-block" id="Atoms.find_neighbors_by_vector"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.find_neighbors_by_vector">[docs]</a>    <span class="k">def</span> <span class="nf">find_neighbors_by_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">,</span> <span class="n">deviation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="o">=</span><span class="mi">96</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            vector (list/np.ndarray): vector by which positions are translated (and neighbors are searched)</span>
<span class="sd">            deviation (bool): whether to return distance between the expect positions and real positions</span>
<span class="sd">            num_neighbors (int): number of neighbors to take into account in get_neighbors</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: list of id&#39;s for the specified translation</span>

<span class="sd">        Example:</span>
<span class="sd">            a_0 = 2.832</span>
<span class="sd">            structure = pr.create_structure(&#39;Fe&#39;, &#39;bcc&#39;, a_0)</span>
<span class="sd">            id_list = structure.find_neighbors_by_vector([0, 0, a_0])</span>
<span class="sd">            # In this example, you get a list of neighbor atom id&#39;s at z+=a_0 for each atom.</span>
<span class="sd">            # This is particularly powerful for SSA when the magnetic structure has to be translated</span>
<span class="sd">            # in each direction.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">neigh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">num_neighbors</span><span class="o">=</span><span class="n">num_neighbors</span><span class="p">)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">vecs</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vector</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deviation</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">neigh</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)],</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">neigh</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)]</span></div>

<div class="viewcode-block" id="Atoms.get_shells"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_shells">[docs]</a>    <span class="k">def</span> <span class="nf">get_shells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_shell</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_num_neighbors</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            id_list:</span>
<span class="sd">            max_shell:</span>
<span class="sd">            max_num_neighbors:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">id_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">id_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">num_neighbors</span><span class="o">=</span><span class="n">max_num_neighbors</span><span class="p">,</span> <span class="n">id_list</span><span class="o">=</span><span class="n">id_list</span><span class="p">)</span>

        <span class="n">shells</span> <span class="o">=</span> <span class="n">neighbors</span><span class="o">.</span><span class="n">shells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">neighbors</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">shell_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i_shell</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">shells</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i_shell</span> <span class="o">&gt;</span> <span class="n">max_shell</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">shell_dict</span><span class="p">[</span><span class="n">i_shell</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">shells</span> <span class="o">==</span> <span class="n">i_shell</span><span class="p">])</span>
            <span class="c1"># print (&quot;shells: &quot;, i_shell, shell_dict[i_shell])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">shell_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="n">max_shell</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">shell_dict</span></div>

<div class="viewcode-block" id="Atoms.get_shell_matrix"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_shell_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_shell_matrix</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">id_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">restraint_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">2</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            neigh_list: user defined get_neighbors (recommended if atoms are displaced from the ideal positions)</span>
<span class="sd">            id_list: cf. get_neighbors</span>
<span class="sd">            radius: cf. get_neighbors</span>
<span class="sd">            num_neighbors: cf. get_neighbors</span>
<span class="sd">            tolerance: cf. get_neighbors</span>
<span class="sd">            restraint_matrix: NxN matrix with True or False, where False will remove the entries.</span>
<span class="sd">                              If an integer is given the sum of the chemical indices corresponding to the number will</span>
<span class="sd">                              be set to True and the rest to False</span>

<span class="sd">        Returns:</span>
<span class="sd">            NxN matrix with 1 for the pairs of atoms in the given shell</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">shell</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">shell</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Parameter &#39;shell&#39; must be an integer greater than 0&quot;</span><span class="p">)</span>
        <span class="n">neigh_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span>
            <span class="n">num_neighbors</span><span class="o">=</span><span class="n">num_neighbors</span><span class="p">,</span> <span class="n">id_list</span><span class="o">=</span><span class="n">id_list</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span>
        <span class="p">)</span>
        <span class="n">Natom</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shell</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shell_lst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">neigh_list</span><span class="o">.</span><span class="n">shells</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shell_lst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">shell</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">restraint_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">restraint_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">Natom</span><span class="p">,</span> <span class="n">Natom</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">restraint_matrix</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">restraint_matrix</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">restraint_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span>
                <span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()</span> <span class="o">==</span> <span class="n">restraint_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()</span> <span class="o">==</span> <span class="n">restraint_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="p">)</span>
            <span class="n">restraint_matrix</span> <span class="o">=</span> <span class="p">(</span><span class="n">restraint_matrix</span> <span class="o">+</span> <span class="n">restraint_matrix</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">shell_matrix_lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">shell</span> <span class="ow">in</span> <span class="n">shell_lst</span><span class="p">:</span>
            <span class="n">shell_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Natom</span><span class="p">,</span> <span class="n">Natom</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ss</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neigh_list</span><span class="o">.</span><span class="n">shells</span><span class="p">):</span>
                <span class="n">unique</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                    <span class="n">neigh_list</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">ss</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shell</span><span class="p">)],</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="n">shell_matrix</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">unique</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span>
            <span class="n">shell_matrix</span><span class="p">[</span><span class="n">restraint_matrix</span> <span class="o">==</span> <span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">shell_matrix_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shell_matrix</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shell_matrix_lst</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">shell_matrix_lst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">shell_matrix_lst</span></div>

<div class="viewcode-block" id="Atoms.get_shell_radius"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_shell_radius">[docs]</a>    <span class="k">def</span> <span class="nf">get_shell_radius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">id_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            shell:</span>
<span class="sd">            id_list:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">id_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">id_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">shells</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shells</span><span class="p">(</span><span class="n">id_list</span><span class="o">=</span><span class="n">id_list</span><span class="p">,</span> <span class="n">max_shell</span><span class="o">=</span><span class="n">shell</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">shells</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="n">shell</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:])</span></div>

<div class="viewcode-block" id="Atoms.occupy_lattice"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.occupy_lattice">[docs]</a>    <span class="k">def</span> <span class="nf">occupy_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">qwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replaces specified indices with a given species</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_species</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">new_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">i_list</span> <span class="ow">in</span> <span class="n">qwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">el</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pse</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">Abbreviation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">Abbreviation</span> <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">new_species</span><span class="p">]:</span>
                <span class="n">new_species</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
                <span class="n">new_indices</span><span class="p">[</span><span class="n">i_list</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_species</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_species</span><span class="p">)</span> <span class="o">==</span> <span class="n">el</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="n">new_indices</span><span class="p">[</span><span class="n">i_list</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
        <span class="n">delete_species_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">retain_species_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_species</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">new_indices</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">delete_species_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">retain_species_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">delete_species_indices</span><span class="p">:</span>
            <span class="n">new_indices</span><span class="p">[</span><span class="n">new_indices</span> <span class="o">&gt;=</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">new_species</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_species</span><span class="p">)[</span><span class="n">retain_species_indices</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_species</span><span class="p">(</span><span class="n">new_species</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">new_indices</span></div>

<div class="viewcode-block" id="Atoms.cluster_analysis"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.cluster_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">cluster_analysis</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">id_list</span><span class="p">,</span> <span class="n">neighbors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_cluster_sizes</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            id_list:</span>
<span class="sd">            neighbors:</span>
<span class="sd">            radius:</span>
<span class="sd">            return_cluster_sizes:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">neighbors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">radius</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shell_radius</span><span class="p">()</span>
                <span class="c1"># print &quot;radius: &quot;, radius</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">t_vec</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_neighbor_index</span> <span class="o">=</span> <span class="n">neighbors</span><span class="o">.</span><span class="n">indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">c_count</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># element_list = self.get_atomic_numbers()</span>
        <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">id_list</span><span class="p">:</span>
            <span class="c1"># el0 = element_list[ia]</span>
            <span class="n">nbrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neighbor_index</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span>
            <span class="c1"># print (&quot;nbrs: &quot;, ia, nbrs)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_count</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__probe_cluster</span><span class="p">(</span><span class="n">c_count</span><span class="p">,</span> <span class="n">nbrs</span><span class="p">,</span> <span class="n">id_list</span><span class="p">)</span>
                <span class="n">c_count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">cluster</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="p">)</span>
        <span class="n">cluster_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">i_c</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cluster</span> <span class="o">==</span> <span class="n">i_c</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">i_c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">c_count</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">return_cluster_sizes</span><span class="p">:</span>
            <span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">i_c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i_c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">cluster_dict</span><span class="p">,</span> <span class="n">sizes</span>

        <span class="k">return</span> <span class="n">cluster_dict</span>  <span class="c1"># sizes</span></div>

    <span class="k">def</span> <span class="nf">__probe_cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c_count</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">id_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            c_count:</span>
<span class="sd">            neighbors:</span>
<span class="sd">            id_list:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">nbr_id</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="p">[</span><span class="n">nbr_id</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nbr_id</span> <span class="ow">in</span> <span class="n">id_list</span><span class="p">:</span>  <span class="c1"># TODO: check also for ordered structures</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cluster</span><span class="p">[</span><span class="n">nbr_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_count</span>
                    <span class="n">nbrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neighbor_index</span><span class="p">[</span><span class="n">nbr_id</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__probe_cluster</span><span class="p">(</span><span class="n">c_count</span><span class="p">,</span> <span class="n">nbrs</span><span class="p">,</span> <span class="n">id_list</span><span class="p">)</span>

    <span class="c1"># TODO: combine with corresponding routine in plot3d</span>
<div class="viewcode-block" id="Atoms.get_bonds"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_bonds">[docs]</a>    <span class="k">def</span> <span class="nf">get_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_shells</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            radius:</span>
<span class="sd">            max_shells:</span>
<span class="sd">            prec: minimum distance between any two clusters (if smaller considered to be single cluster)</span>
<span class="sd">            num_neighbors:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">get_cluster</span><span class="p">(</span><span class="n">dist_vec</span><span class="p">,</span> <span class="n">ind_vec</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="n">prec</span><span class="p">):</span>
            <span class="n">ind_where</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">dist_vec</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">prec</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">ind_vec_cl</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">ind_vec</span><span class="p">,</span> <span class="n">ind_where</span><span class="p">)]</span>
            <span class="n">dist_vec_cl</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dist_vec</span><span class="p">,</span> <span class="n">ind_where</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">ind_vec_cl</span><span class="p">,</span> <span class="n">dist_vec_cl</span>

        <span class="n">neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span>
            <span class="n">cutoff_radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="o">=</span><span class="n">num_neighbors</span>
        <span class="p">)</span>

        <span class="n">dist</span> <span class="o">=</span> <span class="n">neighbors</span><span class="o">.</span><span class="n">distances</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">neighbors</span><span class="o">.</span><span class="n">indices</span>
        <span class="n">el_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()</span>

        <span class="n">ind_shell</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i_a</span><span class="p">,</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="p">)):</span>
            <span class="n">id_list</span><span class="p">,</span> <span class="n">dist_lst</span> <span class="o">=</span> <span class="n">get_cluster</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">radius</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">radius</span><span class="p">])</span>
            <span class="c1"># print (&quot;id: &quot;, d[d&lt;radius], id_list, dist_lst)</span>
            <span class="n">ia_shells_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i_shell_list</span> <span class="ow">in</span> <span class="n">id_list</span><span class="p">:</span>
                <span class="n">ia_shell_dict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">i_s</span> <span class="ow">in</span> <span class="n">i_shell_list</span><span class="p">:</span>
                    <span class="n">el</span> <span class="o">=</span> <span class="n">el_list</span><span class="p">[</span><span class="n">i_s</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">el</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ia_shell_dict</span><span class="p">:</span>
                        <span class="n">ia_shell_dict</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">ia_shell_dict</span><span class="p">[</span><span class="n">el</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i_s</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">el</span><span class="p">,</span> <span class="n">ia_lst</span> <span class="ow">in</span> <span class="n">ia_shell_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">el</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ia_shells_dict</span><span class="p">:</span>
                        <span class="n">ia_shells_dict</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">if</span> <span class="n">max_shells</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia_shells_dict</span><span class="p">[</span><span class="n">el</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">max_shells</span><span class="p">:</span>
                            <span class="k">continue</span>
                    <span class="n">ia_shells_dict</span><span class="p">[</span><span class="n">el</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ia_lst</span><span class="p">)</span>
            <span class="n">ind_shell</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ia_shells_dict</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ind_shell</span></div>

    <span class="c1"># spglib calls</span>
<div class="viewcode-block" id="Atoms.get_symmetry"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_symmetry">[docs]</a>    <span class="k">def</span> <span class="nf">get_symmetry</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">use_magmoms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_elements</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=-</span><span class="mf">1.0</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            use_magmoms:</span>
<span class="sd">            use_elements: True or False. If False, chemical elements will be ignored</span>
<span class="sd">            symprec:</span>
<span class="sd">            angle_tolerance:</span>

<span class="sd">        Returns:</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_cell</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">use_elements</span><span class="p">:</span>
            <span class="n">numbers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_atomic_numbers</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;intc&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numbers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_atomic_numbers</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;intc&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_magmoms</span><span class="p">:</span>
            <span class="n">magmoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_initial_magnetic_moments</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">spglib</span><span class="o">.</span><span class="n">get_symmetry</span><span class="p">(</span>
                <span class="n">cell</span><span class="o">=</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">numbers</span><span class="p">,</span> <span class="n">magmoms</span><span class="p">),</span>
                <span class="n">symprec</span><span class="o">=</span><span class="n">symprec</span><span class="p">,</span>
                <span class="n">angle_tolerance</span><span class="o">=</span><span class="n">angle_tolerance</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">spglib</span><span class="o">.</span><span class="n">get_symmetry</span><span class="p">(</span>
                <span class="n">cell</span><span class="o">=</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">numbers</span><span class="p">),</span>
                <span class="n">symprec</span><span class="o">=</span><span class="n">symprec</span><span class="p">,</span>
                <span class="n">angle_tolerance</span><span class="o">=</span><span class="n">angle_tolerance</span><span class="p">,</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.symmetrize_vectors"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.symmetrize_vectors">[docs]</a>    <span class="k">def</span> <span class="nf">symmetrize_vectors</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">vectors</span><span class="p">,</span> <span class="n">force_update</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_magmoms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_elements</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=-</span><span class="mf">1.0</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Symmetrization of natom x 3 vectors according to box symmetries</span>

<span class="sd">        Args:</span>
<span class="sd">            vectors (ndarray/list): natom x 3 array to symmetrize</span>
<span class="sd">            force_update (bool): whether to update the symmetry info</span>
<span class="sd">            use_magmoms (bool): cf. get_symmetry</span>
<span class="sd">            use_elements (bool): cf. get_symmetry</span>
<span class="sd">            symprec (float): cf. get_symmetry</span>
<span class="sd">            angle_tolerance (float): cf. get_symmetry</span>

<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray) symmetrized vectors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vectors</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vectors</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">vectors</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Vector must be a natom x 3 array: </span><span class="si">{}</span><span class="s1"> != </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vectors</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symmetry_dataset</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">force_update</span><span class="p">:</span>
            <span class="n">symmetry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_symmetry</span><span class="p">(</span><span class="n">use_magmoms</span><span class="o">=</span><span class="n">use_magmoms</span><span class="p">,</span> <span class="n">use_elements</span><span class="o">=</span><span class="n">use_elements</span><span class="p">,</span>
                                         <span class="n">symprec</span><span class="o">=</span><span class="n">symprec</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=</span><span class="n">angle_tolerance</span><span class="p">)</span>
            <span class="n">scaled_positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">symmetry</span><span class="p">[</span><span class="s1">&#39;indices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">rot</span><span class="p">,</span><span class="n">tra</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">symmetry</span><span class="p">[</span><span class="s1">&#39;rotations&#39;</span><span class="p">],</span> <span class="n">symmetry</span><span class="p">[</span><span class="s1">&#39;translations&#39;</span><span class="p">]):</span>
                <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,nj-&gt;ni&#39;</span><span class="p">,</span> <span class="n">rot</span><span class="p">,</span> <span class="n">scaled_positions</span><span class="p">)</span><span class="o">+</span><span class="n">tra</span>
                <span class="n">positions</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">positions</span><span class="o">+</span><span class="mf">1.0e-2</span><span class="p">)</span>
                <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">positions</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">-</span><span class="n">scaled_positions</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;=</span><span class="mf">1.0e-4</span><span class="p">)</span>
                <span class="n">symmetry</span><span class="p">[</span><span class="s1">&#39;indices&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">symmetry</span><span class="p">[</span><span class="s1">&#39;indices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">symmetry</span><span class="p">[</span><span class="s1">&#39;indices&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_symmetry_dataset</span> <span class="o">=</span> <span class="n">symmetry</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ink-&gt;nj&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symmetry_dataset</span><span class="p">[</span><span class="s1">&#39;rotations&#39;</span><span class="p">],</span>
                         <span class="n">vectors</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_symmetry_dataset</span><span class="p">[</span><span class="s1">&#39;indices&#39;</span><span class="p">]])</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_symmetry_dataset</span><span class="p">[</span><span class="s1">&#39;rotations&#39;</span><span class="p">])</span></div>

<div class="viewcode-block" id="Atoms.group_points_by_symmetry"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.group_points_by_symmetry">[docs]</a>    <span class="k">def</span> <span class="nf">group_points_by_symmetry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function classifies the points into groups according to the box symmetry given by spglib.</span>

<span class="sd">            Args:</span>
<span class="sd">                points: (np.array/list) nx3 array which contains positions</span>

<span class="sd">            Returns: list of arrays containing geometrically equivalent positions</span>

<span class="sd">            It is possible that the original points are not found in the returned list, as the positions outsie</span>
<span class="sd">            the box will be projected back to the box.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">struct_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">struct_copy</span> <span class="o">+=</span> <span class="n">Atoms</span><span class="p">(</span><span class="n">elements</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="s2">&quot;Hs&quot;</span><span class="p">],</span> <span class="n">positions</span><span class="o">=</span><span class="n">points</span><span class="p">)</span>
        <span class="n">struct_copy</span><span class="o">.</span><span class="n">center_coordinates_in_unit_cell</span><span class="p">()</span>
        <span class="n">group_IDs</span> <span class="o">=</span> <span class="n">struct_copy</span><span class="o">.</span><span class="n">get_symmetry</span><span class="p">()[</span><span class="s2">&quot;equivalent_atoms&quot;</span><span class="p">][</span>
            <span class="n">struct_copy</span><span class="o">.</span><span class="n">select_index</span><span class="p">(</span><span class="s2">&quot;Hs&quot;</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">group_IDs</span> <span class="o">==</span> <span class="n">ID</span><span class="p">],</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span> <span class="k">for</span> <span class="n">ID</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">group_IDs</span><span class="p">)</span>
        <span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_get_voronoi_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minimum_dist</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function gives the positions of Voronoi vertices</span>
<span class="sd">            This function does not work if there are Hs atoms in the box</span>

<span class="sd">            Args:</span>
<span class="sd">                minimum_dist: Minimum distance between two Voronoi vertices to be considered as one</span>

<span class="sd">            Returns: Positions of Voronoi vertices, box</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vor</span> <span class="o">=</span> <span class="n">Voronoi</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">positions</span>
        <span class="p">)</span>  <span class="c1"># Voronoi package does not have periodic boundary conditions</span>
        <span class="n">b_cell_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
        <span class="n">voro_vert</span> <span class="o">=</span> <span class="n">vor</span><span class="o">.</span><span class="n">vertices</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">voro_vert</span><span class="p">):</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                <span class="n">voro_vert</span><span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">voro_vert</span> <span class="o">-</span> <span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">minimum_dist</span><span class="p">)],</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>  <span class="c1"># Find all points which are within minimum_dist</span>
            <span class="n">voro_vert</span><span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">voro_vert</span> <span class="o">-</span> <span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="mi">3</span> <span class="o">*</span> <span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span>
            <span class="p">)</span>  <span class="c1"># Mark atoms to be deleted afterwards</span>
            <span class="n">voro_vert</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="n">voro_vert</span> <span class="o">=</span> <span class="n">voro_vert</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">voro_vert</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">5</span><span class="p">]</span>

        <span class="n">voro_vert</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b_cell_inv</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">voro_vert</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># get scaled positions</span>
        <span class="n">voro_vert</span> <span class="o">=</span> <span class="n">voro_vert</span><span class="p">[</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">voro_vert</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.499</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">voro_vert</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.501</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">voro_vert</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">voro_vert</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># get true positions</span>

        <span class="n">box_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="n">cell</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Hs&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">voro_vert</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">box_copy</span> <span class="o">+=</span> <span class="n">new_atoms</span>

        <span class="n">pos_total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">voro_vert</span><span class="p">)</span>
        <span class="n">pos_total</span> <span class="o">=</span> <span class="n">pos_total</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">box_copy</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">pos_total</span>

        <span class="n">box_copy</span><span class="o">.</span><span class="n">center_coordinates_in_unit_cell</span><span class="p">()</span>

        <span class="n">neigh</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">box_copy</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">()</span>
        <span class="p">)</span>  <span class="c1"># delete all atoms which lie within minimum_dist (including periodic boundary conditions)</span>
        <span class="k">while</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">distances</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">minimum_dist</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="o">!=</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="k">del</span> <span class="n">box_copy</span><span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">distances</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">minimum_dist</span>
                <span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">]</span>
            <span class="n">neigh</span> <span class="o">=</span> <span class="n">box_copy</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">pos_total</span><span class="p">,</span> <span class="n">box_copy</span>

<div class="viewcode-block" id="Atoms.get_equivalent_voronoi_vertices"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_equivalent_voronoi_vertices">[docs]</a>    <span class="k">def</span> <span class="nf">get_equivalent_voronoi_vertices</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">return_box</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">minimum_dist</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=-</span><span class="mf">1.0</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function gives the positions of spatially equivalent Voronoi vertices in lists, which</span>
<span class="sd">            most likely represent interstitial points or vacancies (along with other high symmetry points)</span>
<span class="sd">            Each list item contains an array of positions which are spacially equivalent.</span>
<span class="sd">            This function does not work if there are Hs atoms in the box</span>

<span class="sd">            Args:</span>
<span class="sd">                return_box: True, if the box containing atoms on the positions of Voronoi vertices</span>
<span class="sd">                            should be returned (which are represented by Hs atoms)</span>
<span class="sd">                minimum_dist: Minimum distance between two Voronoi vertices to be considered as one</span>

<span class="sd">            Returns: List of numpy array positions of spacially equivalent Voronoi vertices</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">box_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_voronoi_vertices</span><span class="p">(</span><span class="n">minimum_dist</span><span class="o">=</span><span class="n">minimum_dist</span><span class="p">)</span>
        <span class="n">list_positions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sym</span> <span class="o">=</span> <span class="n">box_copy</span><span class="o">.</span><span class="n">get_symmetry</span><span class="p">(</span><span class="n">symprec</span><span class="o">=</span><span class="n">symprec</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=</span><span class="n">angle_tolerance</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">sym</span><span class="p">[</span><span class="s2">&quot;equivalent_atoms&quot;</span><span class="p">][</span><span class="n">box_copy</span><span class="o">.</span><span class="n">select_index</span><span class="p">(</span><span class="s2">&quot;Hs&quot;</span><span class="p">)]):</span>
            <span class="n">list_positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">box_copy</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">sym</span><span class="p">[</span><span class="s2">&quot;equivalent_atoms&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">ind</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">return_box</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">list_positions</span><span class="p">,</span> <span class="n">box_copy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">list_positions</span></div>

<div class="viewcode-block" id="Atoms.get_equivalent_points"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_equivalent_points">[docs]</a>    <span class="k">def</span> <span class="nf">get_equivalent_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">use_magmoms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_elements</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            points (list/ndarray): 3d vector</span>
<span class="sd">            use_magmoms (bool): cf. get_symmetry()</span>
<span class="sd">            use_elements (bool): cf. get_symmetry()</span>
<span class="sd">            symprec (float): cf. get_symmetry()</span>
<span class="sd">            angle_tolerance (float): cf. get_symmetry()</span>

<span class="sd">        Returns:</span>
<span class="sd">            (ndarray): array of equivalent points with respect to box symmetries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">symmetry_operations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_symmetry</span><span class="p">(</span><span class="n">use_magmoms</span><span class="o">=</span><span class="n">use_magmoms</span><span class="p">,</span>
                                                <span class="n">use_elements</span><span class="o">=</span><span class="n">use_elements</span><span class="p">,</span>
                                                <span class="n">symprec</span><span class="o">=</span><span class="n">symprec</span><span class="p">,</span>
                                                <span class="n">angle_tolerance</span><span class="o">=</span><span class="n">angle_tolerance</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">symmetry_operations</span><span class="p">[</span><span class="s1">&#39;rotations&#39;</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">symmetry_operations</span><span class="p">[</span><span class="s1">&#39;translations&#39;</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;jk,j-&gt;k&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">),</span> <span class="n">points</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;nxy,y-&gt;nx&#39;</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="n">t</span>
        <span class="n">x</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dist</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">dist</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;</span><span class="n">symprec</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">[</span><span class="n">v</span><span class="o">&lt;</span><span class="n">w</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ji,mj-&gt;mi&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>

<div class="viewcode-block" id="Atoms.get_symmetry_dataset"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_symmetry_dataset">[docs]</a>    <span class="k">def</span> <span class="nf">get_symmetry_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            symprec:</span>
<span class="sd">            angle_tolerance:</span>

<span class="sd">        Returns:</span>

<span class="sd">        https://atztogo.github.io/spglib/python-spglib.html</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_cell</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span>
        <span class="p">)</span>
        <span class="n">numbers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_atomic_numbers</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;intc&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">spglib</span><span class="o">.</span><span class="n">get_symmetry_dataset</span><span class="p">(</span>
            <span class="n">cell</span><span class="o">=</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">numbers</span><span class="p">),</span>
            <span class="n">symprec</span><span class="o">=</span><span class="n">symprec</span><span class="p">,</span>
            <span class="n">angle_tolerance</span><span class="o">=</span><span class="n">angle_tolerance</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.get_spacegroup"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_spacegroup">[docs]</a>    <span class="k">def</span> <span class="nf">get_spacegroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            symprec:</span>
<span class="sd">            angle_tolerance:</span>

<span class="sd">        Returns:</span>

<span class="sd">        https://atztogo.github.io/spglib/python-spglib.html</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_cell</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span>
        <span class="p">)</span>
        <span class="n">numbers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_atomic_numbers</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;intc&quot;</span><span class="p">)</span>
        <span class="n">space_group</span> <span class="o">=</span> <span class="n">spglib</span><span class="o">.</span><span class="n">get_spacegroup</span><span class="p">(</span>
            <span class="n">cell</span><span class="o">=</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">numbers</span><span class="p">),</span>
            <span class="n">symprec</span><span class="o">=</span><span class="n">symprec</span><span class="p">,</span>
            <span class="n">angle_tolerance</span><span class="o">=</span><span class="n">angle_tolerance</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">space_group</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">space_group</span><span class="p">[</span><span class="mi">0</span><span class="p">])}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">&quot;InternationalTableSymbol&quot;</span><span class="p">:</span> <span class="n">space_group</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="s2">&quot;Number&quot;</span><span class="p">:</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">space_group</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="p">}</span></div>

<div class="viewcode-block" id="Atoms.refine_cell"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.refine_cell">[docs]</a>    <span class="k">def</span> <span class="nf">refine_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            symprec:</span>
<span class="sd">            angle_tolerance:</span>

<span class="sd">        Returns:</span>

<span class="sd">        https://atztogo.github.io/spglib/python-spglib.html</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_cell</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span>
        <span class="p">)</span>
        <span class="n">numbers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_atomic_numbers</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;intc&quot;</span><span class="p">)</span>
        <span class="n">cell</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">el</span> <span class="o">=</span> <span class="n">spglib</span><span class="o">.</span><span class="n">refine_cell</span><span class="p">(</span>
            <span class="n">cell</span><span class="o">=</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">numbers</span><span class="p">),</span>
            <span class="n">symprec</span><span class="o">=</span><span class="n">symprec</span><span class="p">,</span>
            <span class="n">angle_tolerance</span><span class="o">=</span><span class="n">angle_tolerance</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">Atoms</span><span class="p">(</span>
            <span class="n">symbols</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()),</span> <span class="n">positions</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="n">cell</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.get_primitive_cell"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_primitive_cell">[docs]</a>    <span class="k">def</span> <span class="nf">get_primitive_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            symprec:</span>
<span class="sd">            angle_tolerance:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">el_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_chemical_elements</span><span class="p">()):</span>
            <span class="n">el_dict</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">AtomicNumber</span><span class="p">]</span> <span class="o">=</span> <span class="n">el</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_cell</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span>
        <span class="p">)</span>
        <span class="n">numbers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_atomic_numbers</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;intc&quot;</span><span class="p">)</span>
        <span class="n">cell</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">atomic_numbers</span> <span class="o">=</span> <span class="n">spglib</span><span class="o">.</span><span class="n">find_primitive</span><span class="p">(</span>
            <span class="n">cell</span><span class="o">=</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">numbers</span><span class="p">),</span>
            <span class="n">symprec</span><span class="o">=</span><span class="n">symprec</span><span class="p">,</span>
            <span class="n">angle_tolerance</span><span class="o">=</span><span class="n">angle_tolerance</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># print atomic_numbers, type(atomic_numbers)</span>
        <span class="n">el_lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">el_dict</span><span class="p">[</span><span class="n">i_a</span><span class="p">]</span> <span class="k">for</span> <span class="n">i_a</span> <span class="ow">in</span> <span class="n">atomic_numbers</span><span class="p">]</span>

        <span class="c1"># convert lattice vectors to standard (experimental feature!) TODO:</span>
        <span class="n">red_structure</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="n">elements</span><span class="o">=</span><span class="n">el_lst</span><span class="p">,</span> <span class="n">scaled_positions</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="n">cell</span><span class="p">)</span>
        <span class="n">space_group</span> <span class="o">=</span> <span class="n">red_structure</span><span class="o">.</span><span class="n">get_spacegroup</span><span class="p">(</span><span class="n">symprec</span><span class="p">)[</span><span class="s2">&quot;Number&quot;</span><span class="p">]</span>
        <span class="c1"># print &quot;space group: &quot;, space_group</span>
        <span class="k">if</span> <span class="n">space_group</span> <span class="o">==</span> <span class="mi">225</span><span class="p">:</span>  <span class="c1"># fcc</span>
            <span class="n">alat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">amat_fcc</span> <span class="o">=</span> <span class="n">alat</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

            <span class="n">red_structure</span><span class="o">.</span><span class="n">cell</span> <span class="o">=</span> <span class="n">amat_fcc</span>
        <span class="k">return</span> <span class="n">red_structure</span></div>

<div class="viewcode-block" id="Atoms.get_ir_reciprocal_mesh"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_ir_reciprocal_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">get_ir_reciprocal_mesh</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">is_shift</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;intc&quot;</span><span class="p">),</span>
        <span class="n">is_time_reversal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">symprec</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            mesh:</span>
<span class="sd">            is_shift:</span>
<span class="sd">            is_time_reversal:</span>
<span class="sd">            symprec:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mapping</span><span class="p">,</span> <span class="n">mesh_points</span> <span class="o">=</span> <span class="n">spglib</span><span class="o">.</span><span class="n">get_ir_reciprocal_mesh</span><span class="p">(</span>
            <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span>
            <span class="n">cell</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">is_shift</span><span class="o">=</span><span class="n">is_shift</span><span class="p">,</span>
            <span class="n">is_time_reversal</span><span class="o">=</span><span class="n">is_time_reversal</span><span class="p">,</span>
            <span class="n">symprec</span><span class="o">=</span><span class="n">symprec</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">mesh_points</span></div>

<div class="viewcode-block" id="Atoms.get_majority_species"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_majority_species">[docs]</a>    <span class="k">def</span> <span class="nf">get_majority_species</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_count</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns the majority species and their number in the box</span>

<span class="sd">        Returns:</span>
<span class="sd">            number of atoms of the majority species, chemical symbol and chemical index</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">el_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_number_species_atoms</span><span class="p">()</span>
        <span class="n">el_num</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">el_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">el_name</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">el_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">el_num</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">el_num</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;There are more than one majority species&quot;</span><span class="p">)</span>
        <span class="n">symbol_to_index</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_chemical_indices</span><span class="p">())</span>
        <span class="p">)</span>
        <span class="n">max_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">el_num</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;symbol&quot;</span><span class="p">:</span> <span class="n">el_name</span><span class="p">[</span><span class="n">max_index</span><span class="p">],</span>
            <span class="s2">&quot;count&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">el_num</span><span class="p">)),</span>
            <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">symbol_to_index</span><span class="p">[</span><span class="n">el_name</span><span class="p">[</span><span class="n">max_index</span><span class="p">]],</span>
        <span class="p">}</span></div>

<div class="viewcode-block" id="Atoms.extend"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.extend">[docs]</a>    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extend atoms object by appending atoms from *other*. Copied from ase</span>

<span class="sd">        Args:</span>
<span class="sd">            other:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Atom</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">([</span><span class="n">other</span><span class="p">])</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">a1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span><span class="p">,)</span> <span class="o">+</span> <span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">a1</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">a</span><span class="p">[:</span><span class="n">n1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a1</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;masses&quot;</span><span class="p">:</span>
                <span class="n">a2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">get_masses</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">lists</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">a2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">a</span><span class="p">[</span><span class="n">n1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">a2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">a2</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">lists</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">continue</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span><span class="p">,)</span> <span class="o">+</span> <span class="n">a2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">a2</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">a</span><span class="p">[:</span><span class="n">n1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a2</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;masses&quot;</span><span class="p">:</span>
                <span class="n">a</span><span class="p">[:</span><span class="n">n1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_masses</span><span class="p">()[:</span><span class="n">n1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span><span class="p">[:</span><span class="n">n1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_length</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span>
        <span class="c1"># Take care of the species and index</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Atoms.append"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append atom to end. Copied from ase</span>

<span class="sd">        Args:</span>
<span class="sd">            atom:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">([</span><span class="n">atom</span><span class="p">]))</span></div>

<div class="viewcode-block" id="Atoms.close"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: implement</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Atoms.get_voronoi_volume"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_voronoi_volume">[docs]</a>    <span class="k">def</span> <span class="nf">get_voronoi_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;This function doesn&#39;t account for periodic boundary conditions. Call &quot;</span>
            <span class="s2">&quot;`analyse_ovito_voronoi_volume` instead. This is what will now be returned.&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">analyse_ovito_voronoi_volume</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Atoms</span><span class="p">):</span>
            <span class="n">sum_atoms</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">sum_atoms</span><span class="o">.</span><span class="n">_tag_list</span> <span class="o">=</span> <span class="n">sum_atoms</span><span class="o">.</span><span class="n">_tag_list</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">_tag_list</span>
            <span class="n">sum_atoms</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sum_atoms</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">sum_atoms</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">sum_atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>

            <span class="n">new_species_lst</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">sum_atoms</span><span class="o">.</span><span class="n">species</span><span class="p">)</span>
            <span class="n">ind_conv</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># self_species_lst = [el.Abbreviation for el in self.species]</span>
            <span class="k">for</span> <span class="n">ind_old</span><span class="p">,</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">species</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">Abbreviation</span> <span class="ow">in</span> <span class="n">sum_atoms</span><span class="o">.</span><span class="n">_store_elements</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="c1"># print (&#39;add:: &#39;, el.Abbreviation, self._store_elements)</span>
                    <span class="n">ind_new</span> <span class="o">=</span> <span class="n">sum_atoms</span><span class="o">.</span><span class="n">_species_to_index_dict</span><span class="p">[</span>
                        <span class="n">sum_atoms</span><span class="o">.</span><span class="n">_store_elements</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">Abbreviation</span><span class="p">]</span>
                    <span class="p">]</span>
                    <span class="n">ind_conv</span><span class="p">[</span><span class="n">ind_old</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind_new</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_species_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
                    <span class="n">sum_atoms</span><span class="o">.</span><span class="n">_store_elements</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">Abbreviation</span><span class="p">]</span> <span class="o">=</span> <span class="n">el</span>
                    <span class="n">ind_conv</span><span class="p">[</span><span class="n">ind_old</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_species_lst</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">new_indices</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">ind_conv</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">new_indices</span><span class="p">[</span><span class="n">new_indices</span> <span class="o">==</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="mi">1000</span>
            <span class="n">new_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">new_indices</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
            <span class="n">sum_atoms</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">new_indices</span>
            <span class="n">sum_atoms</span><span class="o">.</span><span class="n">set_species</span><span class="p">(</span><span class="n">new_species_lst</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sum_atoms</span><span class="o">.</span><span class="n">indices</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">sum_atoms</span><span class="o">.</span><span class="n">species</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Adding the atom instances went wrong!&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">sum_atoms</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Atom</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">([</span><span class="n">other</span><span class="p">])</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copies the atoms object</span>

<span class="sd">        Returns:</span>
<span class="sd">            atoms_new: A copy of the object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms_new</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;_pse&quot;</span><span class="p">]:</span>
                <span class="c1"># print (&#39;copy: &#39;, key)</span>
                <span class="n">atoms_new</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">atoms_new</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">new_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="o">.</span><span class="n">_length</span> <span class="o">=</span> <span class="n">new_length</span>
        <span class="n">deleted_species_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">retain_species_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">new_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">select_index</span><span class="p">(</span><span class="n">el</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">deleted_species_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">new_indices</span><span class="p">[</span><span class="n">new_indices</span> <span class="o">&gt;=</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">retain_species_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">new_species</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()[</span><span class="n">retain_species_indices</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_species</span><span class="p">(</span><span class="n">new_species</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">new_indices</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Atoms</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">()</span>
        <span class="n">conditions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a_1</span><span class="p">,</span> <span class="n">a_2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="n">conditions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a_1</span> <span class="o">==</span> <span class="n">a_2</span><span class="p">)</span>
        <span class="n">conditions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">alltrue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">pbc</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">conditions</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">new_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">item</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">new_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
            <span class="n">element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">item</span><span class="p">]]</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">item</span>
            <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">Atom</span><span class="p">(</span>
                <span class="n">element</span><span class="o">=</span><span class="n">element</span><span class="p">,</span>
                <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span>
                <span class="n">pse</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_pse</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
                <span class="n">atoms</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="o">**</span><span class="n">new_dict</span>
            <span class="p">)</span>

        <span class="n">new_array</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">new_array</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

        <span class="n">new_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">item</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_species_indices</span><span class="p">,</span> <span class="n">new_proper_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
            <span class="n">new_indices</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">new_species</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">new_species_indices</span><span class="p">]</span>
        <span class="n">new_array</span><span class="o">.</span><span class="n">set_species</span><span class="p">(</span><span class="n">new_species</span><span class="p">)</span>
        <span class="n">new_array</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">new_proper_indices</span>
        <span class="n">new_array</span><span class="o">.</span><span class="n">_tag_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="c1"># new_array._tag_list._length = self._tag_list._length</span>
        <span class="n">new_array</span><span class="o">.</span><span class="n">_tag_list</span><span class="o">.</span><span class="n">_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_array</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_array</span><span class="p">,</span> <span class="n">Atom</span><span class="p">):</span>
            <span class="n">natoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">item</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">natoms</span> <span class="ow">or</span> <span class="n">item</span> <span class="o">&gt;=</span> <span class="n">natoms</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Index out of range.&quot;</span><span class="p">)</span>
            <span class="n">new_array</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">item</span>
        <span class="k">return</span> <span class="n">new_array</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="o">.</span><span class="n">_lists</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;[]&quot;</span>
        <span class="n">out_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">el</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">):</span>
            <span class="n">out_str</span> <span class="o">+=</span> <span class="n">el</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_tags</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tags</span><span class="p">()</span>
            <span class="n">out_str</span> <span class="o">+=</span> <span class="s2">&quot;tags: </span><span class="se">\n</span><span class="s2">&quot;</span>  <span class="c1"># + &quot;, &quot;.join(tags) + &quot;\n&quot;</span>
            <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">tags</span><span class="p">:</span>
                <span class="n">out_str</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="s2">&quot;    &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cell</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out_str</span> <span class="o">+=</span> <span class="s2">&quot;pbc: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">out_str</span> <span class="o">+=</span> <span class="s2">&quot;cell: </span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">out_str</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">out_str</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="n">old_el</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">)):</span>
                <span class="n">el</span> <span class="o">=</span> <span class="n">PeriodicTable</span><span class="p">()</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ChemicalElement</span><span class="p">):</span>
                <span class="n">el</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;value should either be a string or a ChemicalElement.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">el</span> <span class="o">!=</span> <span class="n">old_el</span><span class="p">:</span>
                <span class="n">new_species</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">select_index</span><span class="p">(</span><span class="n">old_el</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">Abbreviation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span>
                        <span class="n">spec</span><span class="o">.</span><span class="n">Abbreviation</span> <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">new_species</span>
                    <span class="p">]:</span>
                        <span class="n">new_species</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span> <span class="o">=</span> <span class="n">el</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_species</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">new_species</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">el_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sp</span><span class="o">.</span><span class="n">Abbreviation</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">new_species</span><span class="p">])</span>
                        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">el_list</span> <span class="o">==</span> <span class="n">el</span><span class="o">.</span><span class="n">Abbreviation</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">remove_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                        <span class="n">new_species</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_species</span><span class="p">)</span>
                        <span class="k">del</span> <span class="n">new_species</span><span class="p">[</span><span class="n">remove_index</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">&gt;</span> <span class="n">remove_index</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_species</span><span class="p">(</span><span class="n">new_species</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">Abbreviation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span>
                        <span class="n">spec</span><span class="o">.</span><span class="n">Abbreviation</span> <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">new_species</span>
                    <span class="p">]:</span>
                        <span class="n">new_species</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_species</span><span class="p">)</span>
                        <span class="n">new_species</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_species</span><span class="p">(</span><span class="n">new_species</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_species</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">el_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sp</span><span class="o">.</span><span class="n">Abbreviation</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">new_species</span><span class="p">])</span>
                        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">el_list</span> <span class="o">==</span> <span class="n">el</span><span class="o">.</span><span class="n">Abbreviation</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Generating the correct numpy array from a slice input</span>
                <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">start_val</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">start_val</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">start_val</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span>
                <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">stop_val</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">stop_val</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stop_val</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span>
                <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">step_val</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">step_val</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start_val</span><span class="p">,</span> <span class="n">stop_val</span><span class="p">,</span> <span class="n">step_val</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
                <span class="n">el</span> <span class="o">=</span> <span class="n">PeriodicTable</span><span class="p">()</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ChemicalElement</span><span class="p">):</span>
                <span class="n">el</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The value assigned should be a string, integer or a ChemicalElement instance&quot;</span>
                <span class="p">)</span>
            <span class="n">replace_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="n">new_species</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">:</span>
                <span class="n">replace_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">select_index</span><span class="p">(</span><span class="n">sp</span><span class="p">)),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">select_index</span><span class="p">(</span><span class="n">sp</span><span class="p">),</span> <span class="n">key</span><span class="p">)),</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">Abbreviation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">Abbreviation</span> <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">new_species</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">replace_list</span><span class="p">):</span>
                    <span class="n">new_species</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_species</span><span class="p">(</span><span class="n">new_species</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_species</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">replace_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">replace_list</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">new_species</span><span class="p">[</span><span class="n">replace_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">el</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">replace_list</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">replace_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                            <span class="k">del</span> <span class="n">new_species</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_species</span><span class="p">(</span><span class="n">new_species</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">replace_ind</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">el_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sp</span><span class="o">.</span><span class="n">Abbreviation</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">new_species</span><span class="p">])</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">el_list</span> <span class="o">==</span> <span class="n">el</span><span class="o">.</span><span class="n">Abbreviation</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">replace_list</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_species</span><span class="p">(</span><span class="n">new_species</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>
                    <span class="n">delete_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                    <span class="n">new_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">rep</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">replace_list</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">ind</span> <span class="ow">and</span> <span class="n">rep</span><span class="p">:</span>
                            <span class="n">delete_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                            <span class="c1"># del new_species[i]</span>
                            <span class="n">new_indices</span><span class="p">[</span><span class="n">new_indices</span> <span class="o">&gt;=</span> <span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">new_indices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">new_species</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_species</span><span class="p">)[</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_species</span><span class="p">)),</span> <span class="n">delete_indices</span><span class="p">)</span>
                    <span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_species</span><span class="p">(</span><span class="n">new_species</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="fm">__mul__</span> <span class="o">=</span> <span class="n">repeat</span>

    <span class="k">def</span> <span class="fm">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            vec:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="p">[</span><span class="n">vec</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Box repetition must be an integer or a list/ndarray of integers and not&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">vec</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;Dimension of box repetition not consistent: &#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vec</span><span class="p">),</span> <span class="s1">&#39;!=&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>

        <span class="n">i_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">i_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">i_vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
        <span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">,</span> <span class="n">mz</span> <span class="o">=</span> <span class="n">i_vec</span>
        <span class="n">nx_lst</span><span class="p">,</span> <span class="n">ny_lst</span><span class="p">,</span> <span class="n">nz_lst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">mx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">my</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">mz</span><span class="p">)</span>

        <span class="n">positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">nx_lst</span><span class="p">,</span> <span class="n">ny_lst</span><span class="p">,</span> <span class="n">nz_lst</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">lat_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">new_positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">lat_new</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_positions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_scaled_positions</span><span class="p">(</span><span class="n">new_positions</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">i_vec</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="o">.</span><span class="n">_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># print (&#39;basis_len: &#39;, len(self.positions), len(new_elements))</span>

        <span class="c1"># self.cell = (self.cell.T * np.array(vec)).T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_cell</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vec</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">scale_atoms</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">i_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">i_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">i_vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">*=</span> <span class="n">scale</span>

        <span class="k">return</span> <span class="bp">self</span>  <span class="c1"># to make it compatible with ASE</span>

<div class="viewcode-block" id="Atoms.convert_formula"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.convert_formula">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">convert_formula</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            elements:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">el_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">num_list</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">char</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
            <span class="n">is_last</span> <span class="o">=</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">num_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">char</span><span class="o">.</span><span class="n">isdigit</span><span class="p">())</span> <span class="ow">or</span> <span class="n">is_last</span><span class="p">:</span>
                    <span class="n">el_fac</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">num_list</span><span class="p">)</span> <span class="o">*</span> <span class="n">el_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">el_fac</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                        <span class="n">el_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
                    <span class="n">num_list</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

            <span class="k">if</span> <span class="n">char</span><span class="o">.</span><span class="n">isupper</span><span class="p">():</span>
                <span class="n">el_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">char</span><span class="o">.</span><span class="n">islower</span><span class="p">():</span>
                <span class="n">el_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">char</span>
            <span class="k">elif</span> <span class="n">char</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                <span class="n">num_list</span> <span class="o">+=</span> <span class="n">char</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">num_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># print &quot;num_list: &quot;, el_list, num_list, el_list[-1], (not char.isdigit()) or is_last</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">char</span><span class="o">.</span><span class="n">isdigit</span><span class="p">())</span> <span class="ow">or</span> <span class="n">is_last</span><span class="p">:</span>
                    <span class="n">el_fac</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">num_list</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="n">el_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="c1"># print &quot;el_fac: &quot;, el_fac</span>
                    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">el_fac</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                        <span class="n">el_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
                    <span class="n">num_list</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">return</span> <span class="n">el_list</span></div>

    <span class="c1"># ASE compatibility</span>
    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write atoms object to a recognized file format using ase parsers.</span>

<span class="sd">        see ase.io.write for formats.</span>
<span class="sd">        kwargs are passed to ase.io.write.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pyiron_to_ase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_calculator</span><span class="p">():</span>
        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="Atoms.get_cell"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_cell">[docs]</a>    <span class="k">def</span> <span class="nf">get_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the three unit cell vectors as a 3x3 ndarray.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">complete</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">complete_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cell</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cell</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="Atoms.get_distance"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_distance">[docs]</a>    <span class="k">def</span> <span class="nf">get_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">mic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return distance between two atoms.</span>

<span class="sd">        Use mic=True to use the Minimum Image Convention.</span>
<span class="sd">        vector=True gives the distance vector (from a0 to a1).</span>

<span class="sd">        Args:</span>
<span class="sd">            a0: position or atom ID</span>
<span class="sd">            a1: position or atom ID</span>
<span class="sd">            mic: minimum image convention (True if periodic boundary conditions should be considered)</span>
<span class="sd">            vector: True, if instead of distnce the vector connecting the two positions should be returned</span>

<span class="sd">        Returns: distance or vectors in length unit</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ase.geometry</span> <span class="kn">import</span> <span class="n">find_mic</span>

        <span class="n">positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">()</span>
            <span class="n">a0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a0</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="n">a0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">()</span>
            <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a1</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="n">a1</span><span class="p">]</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a1</span> <span class="o">-</span> <span class="n">a0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">mic</span><span class="p">:</span>
            <span class="n">distance</span><span class="p">,</span> <span class="n">d_len</span> <span class="o">=</span> <span class="n">find_mic</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">distance</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())])</span>
        <span class="k">if</span> <span class="n">vector</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">d_len</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Atoms.get_distances"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_distances">[docs]</a>    <span class="k">def</span> <span class="nf">get_distances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">a1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return distance matrix of every position in p1 with every position in p2</span>

<span class="sd">        Args:</span>
<span class="sd">            a0 (numpy.ndarray/list): Nx3 array of positions</span>
<span class="sd">            a1 (numpy.ndarray/list): Nx3 array of positions</span>
<span class="sd">            mic (bool): minimum image convention</span>
<span class="sd">            vector (bool): return vectors instead of distances</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray NxN if vector=False and NxNx3 if vector=True</span>

<span class="sd">        if a1 is not set, it is assumed that distances between all positions in a0 are desired. a1 will be set to a0 in this case.</span>
<span class="sd">        if both a0 and a1 are not set, the distances between all atoms in the box are returned</span>

<span class="sd">        Use mic to use the minimum image convention.</span>

<span class="sd">        Learn more about get_distances from the ase website:</span>
<span class="sd">        https://wiki.fysik.dtu.dk/ase/ase/geometry.html#ase.geometry.get_distances</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">a0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">a1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a0</span> <span class="o">=</span> <span class="n">a1</span>
            <span class="n">a1</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">a0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span>
        <span class="n">a0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">a1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mic</span><span class="p">:</span>
            <span class="n">vec</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">get_distances</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vec</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">get_distances</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vector</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">vec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dist</span></div>

<div class="viewcode-block" id="Atoms.get_distance_matrix"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_distance_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_distance_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return distances between all atoms in a matrix. cf. get_distance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;get_distance_matrix is deprecated. Use get_distances instead&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_distances</span><span class="p">(</span><span class="n">mic</span><span class="o">=</span><span class="n">mic</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="n">vector</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.get_constraint"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">get_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;selective_dynamics&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="o">.</span><span class="n">_lists</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="kn">from</span> <span class="nn">ase.constraints</span> <span class="kn">import</span> <span class="n">FixAtoms</span>

            <span class="k">return</span> <span class="n">FixAtoms</span><span class="p">(</span>
                <span class="n">indices</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">atom_ind</span>
                        <span class="k">for</span> <span class="n">atom_ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selective_dynamics</span><span class="p">[</span><span class="n">atom_ind</span><span class="p">])</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Atoms.set_constraint"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.set_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">set_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constrain</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">constrain</span><span class="o">.</span><span class="n">todict</span><span class="p">()[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;FixAtoms&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only FixAtoms is supported as ASE compatible constraint.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;selective_dynamics&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="o">.</span><span class="n">_lists</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_tag</span><span class="p">(</span><span class="n">selective_dynamics</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">atom_ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">atom_ind</span> <span class="ow">in</span> <span class="n">constrain</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">selective_dynamics</span><span class="p">[</span><span class="n">atom_ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">selective_dynamics</span><span class="p">[</span><span class="n">atom_ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span></div>

<div class="viewcode-block" id="Atoms.apply_strain"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.apply_strain">[docs]</a>    <span class="k">def</span> <span class="nf">apply_strain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">return_box</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Args:</span>
<span class="sd">                epsilon (float/list/ndarray): epsilon matrix. If a single number is set, the same strain</span>
<span class="sd">                                              is applied in each direction. If a 3-dim vector is set, it</span>
<span class="sd">                                              will be multiplied by a unit matrix.</span>
<span class="sd">                return_box (bool): whether to return a box. If set to True, only the returned box will </span>
<span class="sd">                                   have the desired strain and the original box will stay unchanged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">epsilon</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">epsilon</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">epsilon</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">epsilon</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">epsilon</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">epsilon</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Strain value too negative&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_box</span><span class="p">:</span>
            <span class="n">structure_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">structure_copy</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">structure_copy</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">epsilon</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">cell</span><span class="p">)</span>
        <span class="n">structure_copy</span><span class="o">.</span><span class="n">set_cell</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">scale_atoms</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_box</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">structure_copy</span></div>

<div class="viewcode-block" id="Atoms.get_spherical_coordinates"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_spherical_coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">get_spherical_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Args:</span>
<span class="sd">                x (list/ndarray): coordinates to transform. If not set, the positions</span>
<span class="sd">                                  in structure will be returned.</span>

<span class="sd">            Returns:</span>
<span class="sd">                array in spherical coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">x</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.get_initial_magnetic_moments"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_initial_magnetic_moments">[docs]</a>    <span class="k">def</span> <span class="nf">get_initial_magnetic_moments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get array of initial magnetic moments.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;spin&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="o">.</span><span class="n">_lists</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spin</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spin_lst</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">element</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="s2">&quot;spin&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;spin&quot;</span> <span class="ow">in</span> <span class="n">element</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_chemical_elements</span><span class="p">()</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">spin_lst</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">spin_lst</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="p">(</span>
                        <span class="nb">isinstance</span><span class="p">(</span><span class="n">spin_lst</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span>
                        <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spin_lst</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;[&quot;</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">spin_lst</span><span class="p">))[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="p">[</span>
                                <span class="nb">float</span><span class="p">(</span><span class="n">spin_dir</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">spin_dir</span> <span class="ow">in</span> <span class="n">spin</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                                <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                                <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                                <span class="o">.</span><span class="n">split</span><span class="p">()</span>
                            <span class="p">]</span>
                            <span class="k">if</span> <span class="n">spin</span>
                            <span class="k">else</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="n">spin_lst</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spin_lst</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spin_lst</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">spin</span><span class="p">)</span> <span class="k">if</span> <span class="n">spin</span> <span class="k">else</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="n">spin_lst</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

<div class="viewcode-block" id="Atoms.set_initial_magnetic_moments"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.set_initial_magnetic_moments">[docs]</a>    <span class="k">def</span> <span class="nf">set_initial_magnetic_moments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">magmoms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set array of initial magnetic moments.</span>

<span class="sd">        Args:</span>
<span class="sd">            magmoms (numpy.array()):</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">magmoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">magmoms</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;magmons can be collinear or non-collinear.&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_chemical_elements</span><span class="p">()):</span>
                <span class="k">if</span> <span class="s2">&quot;spin&quot;</span> <span class="ow">in</span> <span class="n">element</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">Parent</span>
            <span class="k">if</span> <span class="s2">&quot;spin&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_list</span><span class="o">.</span><span class="n">_lists</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_tag</span><span class="p">(</span><span class="n">spin</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">spin</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">magmoms</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spin</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">spin</span></div>

<div class="viewcode-block" id="Atoms.pop"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.pop">[docs]</a>    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove and return atom at index *i* (default last).</span>

<span class="sd">        Args:</span>
<span class="sd">            i:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">atom</span><span class="o">.</span><span class="n">cut_reference_to_atoms</span><span class="p">()</span>
        <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">atom</span></div>

<div class="viewcode-block" id="Atoms.rotate"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">rotate_cell</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index_list</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotate atoms based on a vector and an angle, or two vectors. This function is completely adopted from ASE code</span>
<span class="sd">        (https://wiki.fysik.dtu.dk/ase/_modules/ase/atoms.html#Atoms.rotate)</span>

<span class="sd">        Args:</span>

<span class="sd">            rotate_cell:</span>
<span class="sd">            center:</span>
<span class="sd">            vector (list/numpy.ndarray/string):</span>
<span class="sd">                Vector to rotate the atoms around. Vectors can be given as</span>
<span class="sd">                strings: &#39;x&#39;, &#39;-x&#39;, &#39;y&#39;, ... .</span>

<span class="sd">            angle (float/list) in radians = None:</span>
<span class="sd">                Angle that the atoms is rotated around the vecor &#39;v&#39;. If an angle</span>
<span class="sd">                is not specified, the length of &#39;v&#39; is used as the angle</span>
<span class="sd">                (default). The angle can also be a vector and then &#39;v&#39; is rotated</span>
<span class="sd">                into &#39;a&#39;.</span>

<span class="sd">            center = [0, 0, 0]:</span>
<span class="sd">                The center is kept fixed under the rotation. Use &#39;COM&#39; to fix</span>
<span class="sd">                the center of mass, &#39;COP&#39; to fix the center of positions or</span>
<span class="sd">                &#39;COU&#39; to fix the center of cell.</span>

<span class="sd">            rotate_cell = False:</span>
<span class="sd">                If true the cell is also rotated.</span>

<span class="sd">            index_list (list/numpy.ndarray):</span>
<span class="sd">                Indices of atoms to be rotated</span>

<span class="sd">        Examples:</span>

<span class="sd">        Rotate 90 degrees around the z-axis, so that the x-axis is</span>
<span class="sd">        rotated into the y-axis:</span>

<span class="sd">        &gt;&gt;&gt; atoms = Atoms(&#39;H&#39;, [[-0.1, 1.01, -0.5]], cell=[[1, 0, 0], [0, 1, 0], [0, 0, 4]], pbc=[1, 1, 0])</span>
<span class="sd">        &gt;&gt;&gt; a = (22./ 7.) / 2. # pi/2</span>
<span class="sd">        &gt;&gt;&gt; atoms.rotate(&#39;z&#39;, a)</span>
<span class="sd">        &gt;&gt;&gt; atoms.rotate((0, 0, 1), a)</span>
<span class="sd">        &gt;&gt;&gt; atoms.rotate(&#39;-z&#39;, -a)</span>
<span class="sd">        &gt;&gt;&gt; atoms.rotate((0, 0, a))</span>
<span class="sd">        &gt;&gt;&gt; atoms.rotate(&#39;x&#39;, &#39;y&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="n">string2vector</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">angle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="n">vector</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">v2</span> <span class="o">=</span> <span class="n">string2vector</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
            <span class="n">vector</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
            <span class="n">v2</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
            <span class="n">vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
            <span class="c1"># In case *v* and *a* are parallel, np.cross(v, v2) vanish</span>
            <span class="c1"># and can&#39;t be used as a rotation axis. However, in this</span>
            <span class="c1"># case any rotation axis perpendicular to v2 will do.</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-7</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
                <span class="n">vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">v2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">norm</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
                    <span class="n">vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">v2</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">eps</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">vector</span> <span class="o">/=</span> <span class="n">s</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">center</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;com&quot;</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_center_of_mass</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">center</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;cop&quot;</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_positions</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">center</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;cou&quot;</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot interpret center&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">index_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">()</span>
            <span class="n">rotate_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">index_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rotate_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="kc">True</span><span class="p">])</span>

        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">rotate_list</span><span class="p">]</span> <span class="o">-</span> <span class="n">center</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">rotate_list</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">c</span> <span class="o">*</span> <span class="n">p</span>
            <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span> <span class="o">*</span> <span class="n">vector</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">vector</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="n">vector</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">center</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">rotate_cell</span><span class="p">:</span>
            <span class="n">rotcell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span>
            <span class="n">rotcell</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">c</span> <span class="o">*</span> <span class="n">rotcell</span>
                <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">rotcell</span><span class="p">,</span> <span class="n">s</span> <span class="o">*</span> <span class="n">vector</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotcell</span><span class="p">,</span> <span class="n">vector</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="n">vector</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_cell</span><span class="p">(</span><span class="n">rotcell</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.rotate_euler"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.rotate_euler">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_euler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">phi</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">psi</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rotate atoms via Euler angles.</span>

<span class="sd">        See e.g http://mathworld.wolfram.com/EulerAngles.html for explanation.</span>

<span class="sd">        Parameters:</span>

<span class="sd">        center :</span>
<span class="sd">            The point to rotate about. a sequence of length 3 with the</span>
<span class="sd">            coordinates, or &#39;COM&#39; to select the center of mass, &#39;COP&#39; to</span>
<span class="sd">            select center of positions or &#39;COU&#39; to select center of cell.</span>
<span class="sd">        phi :</span>
<span class="sd">            The 1st rotation angle around the z axis (in radian)</span>
<span class="sd">        theta :</span>
<span class="sd">            Rotation around the x axis (in radian)</span>
<span class="sd">        psi :</span>
<span class="sd">            2nd rotation around the z axis (in radian)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">center</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;com&quot;</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_center_of_mass</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">center</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;cop&quot;</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">center</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;cou&quot;</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot interpret center&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>

        <span class="c1"># First move the molecule to the origin In contrast to MATLAB,</span>
        <span class="c1"># numpy broadcasts the smaller array to the larger row-wise,</span>
        <span class="c1"># so there is no need to play with the Kronecker product.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_scaled</span><span class="p">:</span>
            <span class="n">rcoords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="n">center</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rcoords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">center</span>

        <span class="c1"># First Euler rotation about z in matrix form</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">((</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="c1"># Second Euler rotation about x:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
                <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)),</span>
                <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)),</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Third Euler rotation, 2nd rotation about z:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">((</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">),</span> <span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="c1"># Total Euler rotation</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
        <span class="c1"># Do the rotation</span>
        <span class="n">rcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">rcoords</span><span class="p">))</span>
        <span class="c1"># Move back to the rotation point</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_scaled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_scaled_positions</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">rcoords</span><span class="p">)</span> <span class="o">+</span> <span class="n">center</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">rcoords</span><span class="p">)</span> <span class="o">+</span> <span class="n">center</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scaled_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;scaled_positions is deprecated as of vers. 0.2&quot;</span>
            <span class="o">+</span> <span class="s2">&quot; - not guaranteed to work from vers. 0.3 &quot;</span>
            <span class="o">+</span> <span class="s2">&quot;Use get_scaled_positions instead&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">(</span><span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@scaled_positions</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">scaled_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">positions</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;scaled_positions is deprecated as of vers. 0.2&quot;</span>
            <span class="o">+</span> <span class="s2">&quot; - not guaranteed to work from vers. 0.3 &quot;</span>
            <span class="o">+</span> <span class="s2">&quot;Use set_scaled_positions instead&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_scaled_positions</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>

<div class="viewcode-block" id="Atoms.set_scaled_positions"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.set_scaled_positions">[docs]</a>    <span class="k">def</span> <span class="nf">set_scaled_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scaled</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set positions relative to unit cell.</span>

<span class="sd">        Args:</span>
<span class="sd">            scaled (numpy.ndarray/list): The relative coordinates</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cell has not been set yet&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;jk,ij-&gt;ik&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">scaled</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.set_cell"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.set_cell">[docs]</a>    <span class="k">def</span> <span class="nf">set_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="n">scale_atoms</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set unit cell vectors.</span>

<span class="sd">        Parameters:</span>

<span class="sd">        cell: 3x3 matrix or length 3 or 6 vector</span>
<span class="sd">            Unit cell.  A 3x3 matrix (the three unit cell vectors) or</span>
<span class="sd">            just three numbers for an orthorhombic cell. Another option is</span>
<span class="sd">            6 numbers, which describes unit cell with lengths of unit cell</span>
<span class="sd">            vectors and with angles between them (in degrees), in following</span>
<span class="sd">            order: [len(a), len(b), len(c), angle(b,c), angle(a,c),</span>
<span class="sd">            angle(a,b)].  First vector will lie in x-direction, second in</span>
<span class="sd">            xy-plane, and the third one in z-positive subspace.</span>
<span class="sd">        scale_atoms: bool</span>
<span class="sd">            Fix atomic positions or move atoms with the unit cell?</span>
<span class="sd">            Default behavior is to *not* move the atoms (scale_atoms=False).</span>

<span class="sd">        Examples:</span>

<span class="sd">        Two equivalent ways to define an orthorhombic cell:</span>

<span class="sd">        &gt;&gt;&gt; atoms = Atoms(&#39;He&#39;)</span>
<span class="sd">        &gt;&gt;&gt; a, b, c = 7, 7.5, 8</span>
<span class="sd">        &gt;&gt;&gt; atoms.set_cell([a, b, c])</span>
<span class="sd">        &gt;&gt;&gt; atoms.set_cell([(a, 0, 0), (0, b, 0), (0, 0, c)])</span>

<span class="sd">        FCC unit cell:</span>

<span class="sd">        &gt;&gt;&gt; atoms.set_cell([(0, b, b), (b, 0, b), (b, b, 0)])</span>

<span class="sd">        Hexagonal unit cell:</span>

<span class="sd">        &gt;&gt;&gt; atoms.set_cell([a, a, c, 90, 90, 120])</span>

<span class="sd">        Rhombohedral unit cell:</span>

<span class="sd">        &gt;&gt;&gt; alpha = 77</span>
<span class="sd">        &gt;&gt;&gt; atoms.set_cell([a, a, a, alpha, alpha, alpha])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">6</span><span class="p">,):</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="n">cellpar_to_cell</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cell must be length 3 sequence, length 6 &quot;</span> <span class="s2">&quot;sequence or 3x3 matrix!&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">):</span>
            <span class="n">cell_pbc</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">][:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">cell_pbc</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t set a singular matrix/non-right hand orientation &quot;</span>
                                 <span class="s2">&quot;as the cell value for a periodic crystal&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">scale_atoms</span><span class="p">:</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_cell</span><span class="p">(</span><span class="n">complete</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">complete_cell</span><span class="p">(</span><span class="n">cell</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cell</span> <span class="o">=</span> <span class="n">cell</span></div>

<div class="viewcode-block" id="Atoms.set_calculator"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.set_calculator">[docs]</a>    <span class="k">def</span> <span class="nf">set_calculator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Attach calculator object.&quot;&quot;&quot;</span>
        <span class="k">pass</span></div>
     
<div class="viewcode-block" id="Atoms.get_calculator"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.get_calculator">[docs]</a>    <span class="k">def</span> <span class="nf">get_calculator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get currently attached calculator object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span></div>
        
<div class="viewcode-block" id="Atoms.translate"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.translate">[docs]</a>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">displacement</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Translate atomic positions.</span>

<span class="sd">        The displacement argument can be a float, an xyz vector, or an</span>
<span class="sd">        nx3 array (where n is the number of atoms).</span>

<span class="sd">        Args:</span>
<span class="sd">            displacement:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">displacement</span><span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.wrap"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.wrap">[docs]</a>    <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wrap positions to unit cell.</span>

<span class="sd">        Parameters:</span>

<span class="sd">        center: three float</span>
<span class="sd">            The positons in fractional coordinates that the new positions</span>
<span class="sd">            will be nearest possible to.</span>
<span class="sd">        pbc: one or 3 bool</span>
<span class="sd">            For each axis in the unit cell decides whether the positions</span>
<span class="sd">            will be moved along this axis.  By default, the boundary</span>
<span class="sd">            conditions of the Atoms object will be used.</span>
<span class="sd">        eps: float</span>
<span class="sd">            Small number to prevent slightly negative coordinates from beeing</span>
<span class="sd">            wrapped.</span>

<span class="sd">        See also the :func:`ase.utils.geometry.wrap_positions` function.</span>
<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; a = Atoms(&#39;H&#39;,</span>
<span class="sd">        ...           [[-0.1, 1.01, -0.5]],</span>
<span class="sd">        ...           cell=[[1, 0, 0], [0, 1, 0], [0, 0, 4]],</span>
<span class="sd">        ...           pbc=[1, 1, 0])</span>
<span class="sd">        &gt;&gt;&gt; a.wrap()</span>
<span class="sd">        &gt;&gt;&gt; a.positions</span>
<span class="sd">        array([[ 0.9 ,  0.01, -0.5 ]])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">ase.utils.geometry</span> <span class="kn">import</span> <span class="n">wrap_positions</span>

        <span class="k">if</span> <span class="n">pbc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pbc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">wrap_positions</span><span class="p">(</span>
            <span class="n">positions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
            <span class="n">cell</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span>
            <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span>
            <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
            <span class="n">eps</span><span class="o">=</span><span class="n">eps</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Atoms.write"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Atoms.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write atoms object to a file.</span>

<span class="sd">        see ase.io.write for formats.</span>
<span class="sd">        kwargs are passed to ase.io.write.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename:</span>
<span class="sd">            format:</span>
<span class="sd">            **kwargs:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ase.io</span> <span class="kn">import</span> <span class="n">write</span>

        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">arrays</span><span class="p">[</span><span class="s2">&quot;positions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span>
        <span class="n">write</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<span class="k">class</span> <span class="nc">_CrystalStructure</span><span class="p">(</span><span class="n">Atoms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    only for historical reasons</span>

<span class="sd">    Args:</span>
<span class="sd">        element:</span>
<span class="sd">        BravaisLattice:</span>
<span class="sd">        BravaisBasis:</span>
<span class="sd">        LatticeConstants:</span>
<span class="sd">        Dimension:</span>
<span class="sd">        relCoords:</span>
<span class="sd">        PSE:</span>
<span class="sd">        **kwargs:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">element</span><span class="o">=</span><span class="s2">&quot;Fe&quot;</span><span class="p">,</span>
        <span class="n">bravais_lattice</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">,</span>
        <span class="n">bravais_basis</span><span class="o">=</span><span class="s2">&quot;primitive&quot;</span><span class="p">,</span>
        <span class="n">lattice_constants</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># depending on symmetry length and angles</span>
        <span class="n">dimension</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">rel_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">pse</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>

        <span class="c1"># print &quot;basis0&quot;</span>
        <span class="c1"># allow also for scalar input for LatticeConstants (for a cubic system)</span>
        <span class="k">if</span> <span class="n">lattice_constants</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lattice_constants</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">test</span> <span class="o">=</span> <span class="n">lattice_constants</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="n">lattice_constants</span> <span class="o">=</span> <span class="p">[</span><span class="n">lattice_constants</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">=</span> <span class="n">bravais_lattice</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bravais_basis</span> <span class="o">=</span> <span class="n">bravais_basis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lattice_constants</span> <span class="o">=</span> <span class="n">lattice_constants</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relCoords</span> <span class="o">=</span> <span class="n">rel_coords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">element</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__updateCrystal__</span><span class="p">(</span><span class="n">pse</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">crystalParamsDict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;BravaisLattice&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span><span class="p">,</span>
            <span class="s2">&quot;BravaisBasis&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_basis</span><span class="p">,</span>
            <span class="s2">&quot;LatticeConstants&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_constants</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">crystal_lattice_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">3</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;cubic&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;fcc&quot;</span><span class="p">,</span> <span class="s2">&quot;bcc&quot;</span><span class="p">,</span> <span class="s2">&quot;primitive&quot;</span><span class="p">],</span>
                <span class="s2">&quot;hexagonal&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;primitive&quot;</span><span class="p">,</span> <span class="s2">&quot;hcp&quot;</span><span class="p">],</span>
                <span class="s2">&quot;monoclinic&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;primitive&quot;</span><span class="p">,</span> <span class="s2">&quot;base-centered&quot;</span><span class="p">],</span>
                <span class="s2">&quot;triclinic&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;primitive&quot;</span><span class="p">],</span>
                <span class="s2">&quot;orthorombic&quot;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="s2">&quot;primitive&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;body-centered&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;base-centered&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;face-centered&quot;</span><span class="p">,</span>
                <span class="p">],</span>
                <span class="s2">&quot;tetragonal&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;primitive&quot;</span><span class="p">,</span> <span class="s2">&quot;body-centered&quot;</span><span class="p">],</span>
                <span class="s2">&quot;rhombohedral&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;primitive&quot;</span><span class="p">],</span>
            <span class="p">},</span>
            <span class="mi">2</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;oblique&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;primitive&quot;</span><span class="p">],</span>
                <span class="s2">&quot;rectangular&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;primitive&quot;</span><span class="p">,</span> <span class="s2">&quot;centered&quot;</span><span class="p">],</span>
                <span class="s2">&quot;hexagonal&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;primitive&quot;</span><span class="p">],</span>
                <span class="s2">&quot;square&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;primitive&quot;</span><span class="p">],</span>
            <span class="p">},</span>
            <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;line&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;primitive&quot;</span><span class="p">]},</span>
        <span class="p">}</span>

        <span class="c1"># init structure for lattice parameters alat, blat, clat, alpha, beta, gamma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crystalLatticeParams</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">3</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;cubic&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">],</span>
                <span class="s2">&quot;hexagonal&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span>
                <span class="s2">&quot;monoclinic&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">],</span>
                <span class="s2">&quot;triclinic&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">],</span>
                <span class="s2">&quot;orthorombic&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
                <span class="s2">&quot;tetragonal&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span>
                <span class="s2">&quot;rhombohedral&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">],</span>
            <span class="p">},</span>
            <span class="mi">2</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;oblique&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">],</span>
                <span class="s2">&quot;rectangular&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
                <span class="s2">&quot;hexagonal&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">],</span>
                <span class="s2">&quot;square&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">],</span>
            <span class="p">},</span>
            <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;line&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]},</span>
        <span class="p">}</span>

        <span class="c1"># print &quot;basis&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_CrystalStructure</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">elements</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ElementList</span><span class="p">,</span>
            <span class="n">scaled_positions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span>
            <span class="n">cell</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">amat</span><span class="p">,</span>  <span class="c1"># tag = &quot;Crystal&quot;,</span>
            <span class="n">pbc</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">][</span><span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">],</span>
        <span class="p">)</span>

    <span class="c1"># ## private member functions</span>
    <span class="k">def</span> <span class="nf">__updateCrystal__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pse</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            pse:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__updateAmat__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__updateCoordinates__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__updateElementList__</span><span class="p">(</span><span class="n">pse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__updateAmat__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># TODO: avoid multi-call of this function</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print &quot;lat constants (__updateAmat__):&quot;, self.LatticeConstants</span>
        <span class="n">a_lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_constants</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">b_lat</span><span class="p">,</span> <span class="n">c_lat</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">==</span> <span class="s2">&quot;cubic&quot;</span><span class="p">:</span>
                <span class="n">b_lat</span> <span class="o">=</span> <span class="n">c_lat</span> <span class="o">=</span> <span class="n">a_lat</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mi">90</span> <span class="o">/</span> <span class="mf">180.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>  <span class="c1"># 90 degrees</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">==</span> <span class="s2">&quot;tetragonal&quot;</span><span class="p">:</span>
                <span class="n">b_lat</span> <span class="o">=</span> <span class="n">a_lat</span>
                <span class="n">c_lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_constants</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>  <span class="c1"># 90 degrees</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">==</span> <span class="s2">&quot;triclinic&quot;</span><span class="p">:</span>
                <span class="n">b_lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_constants</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">c_lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_constants</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_constants</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">/</span> <span class="mf">180.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_constants</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">/</span> <span class="mf">180.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_constants</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">/</span> <span class="mf">180.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">==</span> <span class="s2">&quot;hexagonal&quot;</span><span class="p">:</span>
                <span class="n">b_lat</span> <span class="o">=</span> <span class="n">a_lat</span>
                <span class="n">c_lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_constants</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="mf">60.0</span> <span class="o">/</span> <span class="mf">180.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>  <span class="c1"># 60 degrees</span>
                <span class="n">beta</span> <span class="o">=</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>  <span class="c1"># 90 degrees</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">==</span> <span class="s2">&quot;orthorombic&quot;</span><span class="p">:</span>
                <span class="n">b_lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_constants</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">c_lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_constants</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>  <span class="c1"># 90 degrees</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">==</span> <span class="s2">&quot;rhombohedral&quot;</span><span class="p">:</span>
                <span class="n">b_lat</span> <span class="o">=</span> <span class="n">a_lat</span>
                <span class="n">c_lat</span> <span class="o">=</span> <span class="n">a_lat</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_constants</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mf">180.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_constants</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="mf">180.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_constants</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">/</span> <span class="mf">180.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">==</span> <span class="s2">&quot;monoclinic&quot;</span><span class="p">:</span>
                <span class="n">b_lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_constants</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">c_lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_constants</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_constants</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">/</span> <span class="mf">180.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

            <span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
            <span class="n">b2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">amat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">[</span><span class="n">a_lat</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                    <span class="p">[</span><span class="n">b_lat</span> <span class="o">*</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b_lat</span> <span class="o">*</span> <span class="n">b2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                    <span class="p">[</span><span class="n">c_lat</span> <span class="o">*</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c_lat</span> <span class="o">*</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c_lat</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">c2</span> <span class="o">*</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span> <span class="o">*</span> <span class="n">c1</span><span class="p">)],</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># TODO not finished yet</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">amat</span> <span class="o">=</span> <span class="n">a_lat</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">==</span> <span class="s2">&quot;rectangular&quot;</span><span class="p">:</span>
                <span class="n">b_lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_constants</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">amat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">a_lat</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">b_lat</span><span class="p">]])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">amat</span> <span class="o">=</span> <span class="n">a_lat</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bravais lattice not defined!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__updateElementList__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pse</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            pse:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ElementList</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__updateCoordinates__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if relative coordinates</span>
        <span class="n">basis</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_basis</span> <span class="o">==</span> <span class="s2">&quot;fcc&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_basis</span> <span class="o">==</span> <span class="s2">&quot;face-centered&quot;</span><span class="p">:</span>
                <span class="n">basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]]</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_basis</span> <span class="o">==</span> <span class="s2">&quot;body-centered&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_basis</span> <span class="o">==</span> <span class="s2">&quot;bcc&quot;</span><span class="p">:</span>
                <span class="n">basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]])</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_basis</span> <span class="o">==</span> <span class="s2">&quot;base-centered&quot;</span><span class="p">:</span>
                <span class="n">basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]])</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_basis</span> <span class="o">==</span> <span class="s2">&quot;hcp&quot;</span><span class="p">:</span>
                <span class="c1"># basis = r([[0.0,-1./np.sqrt(3.),np.sqrt(8./3.)]])</span>
                <span class="c1"># a = self.LatticeConstants[0]</span>
                <span class="c1"># c = self.LatticeConstants[1]</span>
                <span class="n">basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">]])</span>
                <span class="c1"># basis = np.dot(basis,np.linalg.inv(self.amat))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_basis</span> <span class="o">==</span> <span class="s2">&quot;primitive&quot;</span><span class="p">:</span>
                <span class="n">basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exit</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_basis</span> <span class="o">==</span> <span class="s2">&quot;primitive&quot;</span><span class="p">:</span>
                <span class="n">basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]])</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_basis</span> <span class="o">==</span> <span class="s2">&quot;centered&quot;</span><span class="p">:</span>
                <span class="n">basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exit</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_basis</span> <span class="o">==</span> <span class="s2">&quot;primitive&quot;</span><span class="p">:</span>
                <span class="n">basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exit</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">basis</span>

    <span class="c1"># ########################### get commmands ########################</span>
    <span class="k">def</span> <span class="nf">get_lattice_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crystal_lattice_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">crystal_lattice_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_dimension_of_lattice_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print &quot;getDimensionOfLatticeParameters&quot;</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_needed_lattice_parameters</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">counter</span>

    <span class="k">def</span> <span class="nf">get_needed_lattice_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print &quot;call: getNeededLatticeParams&quot;</span>
        <span class="n">needed_params</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">==</span> <span class="s2">&quot;cubic&quot;</span><span class="p">:</span>
                <span class="n">needed_params</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="kc">True</span><span class="p">,</span>
                    <span class="kc">False</span><span class="p">,</span>
                    <span class="kc">False</span><span class="p">,</span>
                    <span class="kc">False</span><span class="p">,</span>
                    <span class="kc">False</span><span class="p">,</span>
                    <span class="kc">False</span><span class="p">,</span>
                <span class="p">]</span>  <span class="c1"># stands for alat, blat, clat, alpha, beta, gamma</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">==</span> <span class="s2">&quot;triclinic&quot;</span><span class="p">:</span>
                <span class="n">needed_params</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">==</span> <span class="s2">&quot;monoclinic&quot;</span><span class="p">:</span>
                <span class="n">needed_params</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">==</span> <span class="s2">&quot;orthorombic&quot;</span><span class="p">:</span>
                <span class="n">needed_params</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">==</span> <span class="s2">&quot;tetragonal&quot;</span><span class="p">:</span>
                <span class="n">needed_params</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">==</span> <span class="s2">&quot;rhombohedral&quot;</span><span class="p">:</span>
                <span class="n">needed_params</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">==</span> <span class="s2">&quot;hexagonal&quot;</span><span class="p">:</span>
                <span class="n">needed_params</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">==</span> <span class="s2">&quot;oblique&quot;</span><span class="p">:</span>
                <span class="n">needed_params</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">==</span> <span class="s2">&quot;rectangular&quot;</span><span class="p">:</span>
                <span class="n">needed_params</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">==</span> <span class="s2">&quot;hexagonal&quot;</span><span class="p">:</span>
                <span class="n">needed_params</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">==</span> <span class="s2">&quot;square&quot;</span><span class="p">:</span>
                <span class="n">needed_params</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># TODO: need to be improved</span>
                <span class="n">needed_params</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">==</span> <span class="s2">&quot;line&quot;</span><span class="p">:</span>
                <span class="n">needed_params</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># TODO: improval needed</span>
                <span class="n">needed_params</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;inconsistency in lattice structures&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">needed_params</span>

    <span class="k">def</span> <span class="nf">get_basis_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crystal_lattice_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span><span class="p">)</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">crystal_lattice_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_initial_lattice_constants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crystalLatticeParams</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span><span class="p">)</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">crystalLatticeParams</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span><span class="p">)</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="c1"># def getDimension(self):</span>
    <span class="c1">#     return self.dimension</span>

    <span class="c1"># def getCoordinates(self):</span>
    <span class="c1">#     return self.coordinates</span>

    <span class="c1"># def getCell(self):</span>
    <span class="c1">#     return self.amat</span>

    <span class="k">def</span> <span class="nf">get_atom_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            rel:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#        print self.relCoords, self.amat</span>
        <span class="k">return</span> <span class="n">Atoms</span><span class="p">(</span>
            <span class="n">elementList</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ElementList</span><span class="p">,</span>
            <span class="n">coordinates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span>
            <span class="n">amat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">amat</span><span class="p">,</span>
            <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;Crystal&quot;</span><span class="p">,</span>
            <span class="n">rel</span><span class="o">=</span><span class="n">rel</span><span class="p">,</span>  <span class="c1"># self.relCoords, #rel, # true or false # coordinates are given in relative lattice units</span>
            <span class="n">pbc</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">][</span><span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">],</span>
            <span class="n">Crystal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crystalParamsDict</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># #################### set commands #########################</span>
    <span class="k">def</span> <span class="nf">set_lattice_constants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lattice_constants</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            lattice_constants:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lattice_constants</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lattice_constants</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">lattice_constants</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;negative lattice parameter(s)&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lattice_constants</span> <span class="o">=</span> <span class="n">lattice_constants</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__updateCrystal__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">set_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="o">=</span><span class="s2">&quot;Fe&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            element:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">element</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__updateCrystal__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">set_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            dim:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">dim</span>
        <span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dimension_of_lattice_parameters</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># # initial 3d structure</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lattice_constants</span> <span class="o">=</span> <span class="n">length</span> <span class="o">*</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">=</span> <span class="s2">&quot;cubic&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bravais_basis</span> <span class="o">=</span> <span class="s2">&quot;primitive&quot;</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># # initial 2d structure</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lattice_constants</span> <span class="o">=</span> <span class="n">length</span> <span class="o">*</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">=</span> <span class="s2">&quot;square&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bravais_basis</span> <span class="o">=</span> <span class="s2">&quot;primitive&quot;</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># # initial 1d structure</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lattice_constants</span> <span class="o">=</span> <span class="n">length</span> <span class="o">*</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">=</span> <span class="s2">&quot;line&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bravais_basis</span> <span class="o">=</span> <span class="s2">&quot;primitive&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__updateCrystal__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">set_lattice_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_lattice</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            name_lattice:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># catch input error</span>
        <span class="c1"># print &quot;lattice type =&quot;, name_lattice</span>
        <span class="k">if</span> <span class="n">name_lattice</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lattice_types</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;is not item of &quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">=</span> <span class="n">name_lattice</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_lattice_constants</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_dimension_of_lattice_parameters</span><span class="p">()</span> <span class="o">*</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_basis_type</span><span class="p">(</span>
                <span class="n">name_basis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crystal_lattice_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name_lattice</span><span class="p">)[</span>
                    <span class="mi">0</span>
                <span class="p">]</span>
            <span class="p">)</span>  <span class="c1"># initial basis type</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__updateCrystal__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">set_basis_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_basis</span><span class="o">=</span><span class="s2">&quot;primitive&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            name_basis:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name_basis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_basis_types</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;is not item of&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bravais_basis</span> <span class="o">=</span> <span class="n">name_basis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__updateCrystal__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Atoms</span><span class="p">(</span>
            <span class="n">elements</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ElementList</span><span class="p">,</span>
            <span class="n">scaled_positions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span>
            <span class="n">cell</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">amat</span><span class="p">,</span>
            <span class="n">pbc</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">][</span><span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">],</span>
        <span class="p">)</span>


<div class="viewcode-block" id="Neighbors"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.Neighbors">[docs]</a><span class="k">class</span> <span class="nc">Neighbors</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for storage of the neighbor information for a given atom based on the KDtree algorithm</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_distances</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vecs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shells</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">distances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distances</span>

    <span class="nd">@distances</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">distances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_distances</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_distances</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_distances</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_distances</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only lists and np.arrays are supported.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vecs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vecs</span>

    <span class="nd">@vecs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">vecs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_vecs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_vecs</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_vecs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_vecs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only lists and np.arrays are supported.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span>

    <span class="nd">@indices</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_indices</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_indices</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_indices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_indices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only lists and np.arrays are supported.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shells</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shells</span>

    <span class="nd">@shells</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">shells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_shells</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_shells</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_shells</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_shells</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only lists and np.arrays are supported.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="CrystalStructure"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.CrystalStructure">[docs]</a><span class="k">class</span> <span class="nc">CrystalStructure</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">basis</span> <span class="o">=</span> <span class="n">_CrystalStructure</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">basis</span></div>


<div class="viewcode-block" id="ase_to_pyiron"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.ase_to_pyiron">[docs]</a><span class="k">def</span> <span class="nf">ase_to_pyiron</span><span class="p">(</span><span class="n">ase_obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Args:</span>
<span class="sd">        ase_obj:</span>

<span class="sd">    Returns:</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">ase</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ASE package not yet installed&quot;</span><span class="p">)</span>
    <span class="n">element_list</span> <span class="o">=</span> <span class="n">ase_obj</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()</span>
    <span class="n">cell</span> <span class="o">=</span> <span class="n">ase_obj</span><span class="o">.</span><span class="n">cell</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="n">ase_obj</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()</span>
    <span class="n">pbc</span> <span class="o">=</span> <span class="n">ase_obj</span><span class="o">.</span><span class="n">get_pbc</span><span class="p">()</span>
    <span class="n">spins</span> <span class="o">=</span> <span class="n">ase_obj</span><span class="o">.</span><span class="n">get_initial_magnetic_moments</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">spins</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">spins</span><span class="p">))</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">pyiron_atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span>
            <span class="n">elements</span><span class="o">=</span><span class="n">element_list</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="n">positions</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="n">cell</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">spins</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">None</span><span class="p">)):</span>
            <span class="n">spins</span><span class="p">[</span><span class="n">spins</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">pyiron_atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span>
            <span class="n">elements</span><span class="o">=</span><span class="n">element_list</span><span class="p">,</span>
            <span class="n">positions</span><span class="o">=</span><span class="n">positions</span><span class="p">,</span>
            <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span>
            <span class="n">cell</span><span class="o">=</span><span class="n">cell</span><span class="p">,</span>
            <span class="n">magmoms</span><span class="o">=</span><span class="n">spins</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ase_obj</span><span class="p">,</span> <span class="s2">&quot;constraints&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">ase_obj</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">ase_obj</span><span class="o">.</span><span class="n">constraints</span><span class="p">:</span>
            <span class="n">constraint_dict</span> <span class="o">=</span> <span class="n">constraint</span><span class="o">.</span><span class="n">todict</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">constraint_dict</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;FixAtoms&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;selective_dynamics&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pyiron_atoms</span><span class="o">.</span><span class="n">_tag_list</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">pyiron_atoms</span><span class="o">.</span><span class="n">add_tag</span><span class="p">(</span><span class="n">selective_dynamics</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
                <span class="n">pyiron_atoms</span><span class="o">.</span><span class="n">selective_dynamics</span><span class="p">[</span>
                    <span class="n">constraint_dict</span><span class="p">[</span><span class="s2">&quot;kwargs&quot;</span><span class="p">][</span><span class="s2">&quot;indices&quot;</span><span class="p">]</span>
                <span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">constraint_dict</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;FixScaled&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;selective_dynamics&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pyiron_atoms</span><span class="o">.</span><span class="n">_tag_list</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">pyiron_atoms</span><span class="o">.</span><span class="n">add_tag</span><span class="p">(</span><span class="n">selective_dynamics</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
                <span class="n">pyiron_atoms</span><span class="o">.</span><span class="n">selective_dynamics</span><span class="p">[</span>
                    <span class="n">constraint_dict</span><span class="p">[</span><span class="s2">&quot;kwargs&quot;</span><span class="p">][</span><span class="s2">&quot;a&quot;</span><span class="p">]</span>
                <span class="p">]</span> <span class="o">=</span> <span class="n">constraint_dict</span><span class="p">[</span><span class="s2">&quot;kwargs&quot;</span><span class="p">][</span><span class="s2">&quot;mask&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Unsupported ASE constraint: &quot;</span> <span class="o">+</span> <span class="n">constraint_dict</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">pyiron_atoms</span></div>


<div class="viewcode-block" id="pyiron_to_ase"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.pyiron_to_ase">[docs]</a><span class="k">def</span> <span class="nf">pyiron_to_ase</span><span class="p">(</span><span class="n">pyiron_obj</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pyiron.atomistics.structure.pyironase</span> <span class="kn">import</span> <span class="n">ASEAtoms</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ASE package not yet installed&quot;</span><span class="p">)</span>
    <span class="n">element_list</span> <span class="o">=</span> <span class="n">pyiron_obj</span><span class="o">.</span><span class="n">get_parent_symbols</span><span class="p">()</span>
    <span class="n">cell</span> <span class="o">=</span> <span class="n">pyiron_obj</span><span class="o">.</span><span class="n">cell</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="n">pyiron_obj</span><span class="o">.</span><span class="n">positions</span>
    <span class="n">pbc</span> <span class="o">=</span> <span class="n">pyiron_obj</span><span class="o">.</span><span class="n">get_pbc</span><span class="p">()</span>
    <span class="n">spins</span> <span class="o">=</span> <span class="n">pyiron_obj</span><span class="o">.</span><span class="n">get_initial_magnetic_moments</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">spins</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">spins</span><span class="p">))</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">ASEAtoms</span><span class="p">(</span><span class="n">symbols</span><span class="o">=</span><span class="n">element_list</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="n">positions</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="n">cell</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">spins</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">None</span><span class="p">)):</span>
            <span class="n">spins</span><span class="p">[</span><span class="n">spins</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">ASEAtoms</span><span class="p">(</span>
            <span class="n">symbols</span><span class="o">=</span><span class="n">element_list</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="n">positions</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="n">cell</span><span class="p">,</span> <span class="n">magmoms</span><span class="o">=</span><span class="n">spins</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">atoms</span></div>


<span class="k">def</span> <span class="nf">_check_if_simple_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Raise a warning if the ASE atoms object includes properties which can not be converted to pymatgen atoms.</span>

<span class="sd">    Args:</span>
<span class="sd">        atoms: ASE atoms object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dict_keys</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">k</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">k</span>
        <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;_celldisp&quot;</span><span class="p">,</span> <span class="s2">&quot;arrays&quot;</span><span class="p">,</span> <span class="s2">&quot;_cell&quot;</span><span class="p">,</span> <span class="s2">&quot;_pbc&quot;</span><span class="p">,</span> <span class="s2">&quot;_constraints&quot;</span><span class="p">,</span> <span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="s2">&quot;_calc&quot;</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="n">array_keys</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;arrays&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;numbers&quot;</span><span class="p">,</span> <span class="s2">&quot;positions&quot;</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">dict_keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Found unknown keys: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dict_keys</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_celldisp&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]])):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Found cell displacement: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_celldisp&quot;</span><span class="p">]))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">atoms</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_calc&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Found calculator: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_calc&quot;</span><span class="p">]))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">atoms</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_constraints&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Found constraint: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_constraints&quot;</span><span class="p">]))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_pbc&quot;</span><span class="p">]):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cell is not periodic: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_pbc&quot;</span><span class="p">]))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">array_keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Found unknown flags: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">array_keys</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">atoms</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;info&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Info is not empty: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;info&quot;</span><span class="p">]))</span>


<div class="viewcode-block" id="pymatgen_to_pyiron"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.pymatgen_to_pyiron">[docs]</a><span class="k">def</span> <span class="nf">pymatgen_to_pyiron</span><span class="p">(</span><span class="n">pymatgen_obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert pymatgen atoms object to pyiron atoms object (pymatgen-&gt;ASE-&gt;pyiron)</span>

<span class="sd">    Args:</span>
<span class="sd">        pymatgen_obj: pymatgen atoms object</span>

<span class="sd">    Returns:</span>
<span class="sd">        pyiron atoms object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pymatgen.io.ase</span> <span class="kn">import</span> <span class="n">AseAtomsAdaptor</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;PyMatGen package not yet installed&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ase_to_pyiron</span><span class="p">(</span><span class="n">AseAtomsAdaptor</span><span class="p">()</span><span class="o">.</span><span class="n">get_atoms</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="n">pymatgen_obj</span><span class="p">))</span></div>


<div class="viewcode-block" id="pyiron_to_pymatgen"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.pyiron_to_pymatgen">[docs]</a><span class="k">def</span> <span class="nf">pyiron_to_pymatgen</span><span class="p">(</span><span class="n">pyiron_obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert pyiron atoms object to pymatgen atoms object</span>

<span class="sd">    Args:</span>
<span class="sd">        pyiron_obj: pyiron atoms object</span>

<span class="sd">    Returns:</span>
<span class="sd">        pymatgen atoms object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pymatgen.io.ase</span> <span class="kn">import</span> <span class="n">AseAtomsAdaptor</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;PyMatGen package not yet installed&quot;</span><span class="p">)</span>
    <span class="n">ase_atoms</span> <span class="o">=</span> <span class="n">pyiron_to_ase</span><span class="p">(</span><span class="n">pyiron_obj</span><span class="p">)</span>
    <span class="n">_check_if_simple_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="o">=</span><span class="n">ase_atoms</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">AseAtomsAdaptor</span><span class="p">()</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="n">atoms</span><span class="o">=</span><span class="n">ase_atoms</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="ovito_to_pyiron"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.ovito_to_pyiron">[docs]</a><span class="k">def</span> <span class="nf">ovito_to_pyiron</span><span class="p">(</span><span class="n">ovito_obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Args:</span>
<span class="sd">        ovito_obj:</span>

<span class="sd">    Returns:</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">ovito.data</span> <span class="kn">import</span> <span class="n">ase_to_pyiron</span>

        <span class="k">return</span> <span class="n">ase_to_pyiron</span><span class="p">(</span><span class="n">ovito_obj</span><span class="o">.</span><span class="n">to_ase_atoms</span><span class="p">())</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ovito package not yet installed&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="pyiron_to_ovito"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.pyiron_to_ovito">[docs]</a><span class="k">def</span> <span class="nf">pyiron_to_ovito</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Args:</span>
<span class="sd">        atoms:</span>

<span class="sd">    Returns:</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">ovito.data</span> <span class="kn">import</span> <span class="n">DataCollection</span>

        <span class="k">return</span> <span class="n">DataCollection</span><span class="o">.</span><span class="n">create_from_ase_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ovito package not yet installed&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="string2symbols"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.string2symbols">[docs]</a><span class="k">def</span> <span class="nf">string2symbols</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert string to list of chemical symbols.</span>

<span class="sd">    Args:</span>
<span class="sd">        s:</span>

<span class="sd">    Returns:</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">string2symbols</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
    <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s2">&quot;(&quot;</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s2">&quot;(&quot;</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="s2">&quot;)&quot;</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">j</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">m</span> <span class="o">*</span> <span class="n">string2symbols</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">string2symbols</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">:])</span>

    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">isupper</span><span class="p">():</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">islower</span><span class="p">():</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">m</span> <span class="o">*</span> <span class="p">[</span><span class="n">s</span><span class="p">[:</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="n">string2symbols</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">:])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span></div>


<div class="viewcode-block" id="symbols2numbers"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.symbols2numbers">[docs]</a><span class="k">def</span> <span class="nf">symbols2numbers</span><span class="p">(</span><span class="n">symbols</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Args:</span>
<span class="sd">        symbols (list, str):</span>

<span class="sd">    Returns:</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pse</span> <span class="o">=</span> <span class="n">PeriodicTable</span><span class="p">()</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pse</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="n">string2symbols</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>
    <span class="n">numbers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">numbers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">sym</span><span class="p">][</span><span class="s2">&quot;AtomicNumber&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numbers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">numbers</span></div>


<div class="viewcode-block" id="string2vector"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.string2vector">[docs]</a><span class="k">def</span> <span class="nf">string2vector</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Args:</span>
<span class="sd">        v:</span>

<span class="sd">    Returns:</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">string2vector</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">w</span><span class="p">[</span><span class="s2">&quot;xyz&quot;</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">return</span> <span class="n">w</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span></div>


<div class="viewcode-block" id="default"><a class="viewcode-back" href="../../../../apidoc/pyiron.atomistics.structure.atoms.html#pyiron.atomistics.structure.atoms.default">[docs]</a><span class="k">def</span> <span class="nf">default</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dflt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function for setting default values.</span>

<span class="sd">    Args:</span>
<span class="sd">        data:</span>
<span class="sd">        dflt:</span>

<span class="sd">    Returns:</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">newdata</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">allnone</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">newdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dflt</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">allnone</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">allnone</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">newdata</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2019, Max-Planck-Institut für Eisenforschung GmbH - Computational Materials Design (CM) Department All rights reserved

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>